<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Capítulo 9 - Infraestructura Cloud y Orquestación con Kubernetes</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>

<div class="nav-header">
    <h2>Capítulo 9: Infraestructura Cloud y Orquestación con Kubernetes</h2>
    <div class="nav-buttons">
        <a href="capitulo_08.html" class="nav-btn">← Anterior</a>
        <a href="index.html" class="nav-btn">Índice</a>
        <a href="capitulo_10.html" class="nav-btn">Siguiente →</a>
    </div>
</div>

<h1>9. INFRAESTRUCTURA CLOUD Y ORQUESTACIÓN CON KUBERNETES</h1>

<h2>9.1 Estrategia de Despliegue Multi-Ambiente</h2>

<div class="section">
    <p>El sistema se desplegará en Kubernetes con <strong>3 ambientes separados</strong> para garantizar aislamiento y permitir testing exhaustivo antes de llegar a producción.</p>

    <table>
        <thead>
            <tr>
                <th>Ambiente</th>
                <th>Nodos</th>
                <th>Pods por Servicio</th>
                <th>CPU/RAM por Pod</th>
                <th>Propósito</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Producción</strong></td>
                <td>2 nodos</td>
                <td>3 réplicas</td>
                <td>2 CPU / 4GB RAM</td>
                <td>Usuarios finales, 99.9% uptime</td>
            </tr>
            <tr>
                <td><strong>Pre-Producción</strong></td>
                <td>2 nodos</td>
                <td>2 réplicas</td>
                <td>1 CPU / 2GB RAM</td>
                <td>Testing final, staging, validación</td>
            </tr>
            <tr>
                <td><strong>Desarrollo</strong></td>
                <td>1 nodo</td>
                <td>2 pods (Dev + QA)</td>
                <td>0.5 CPU / 1GB RAM</td>
                <td>Desarrollo activo, testing de features</td>
            </tr>
        </tbody>
    </table>

    <div class="justification">
        <div class="justification-title">Justificación de la Estrategia</div>
        <ul>
            <li><strong>Producción (2 nodos):</strong> Alta disponibilidad con anti-affinity rules. Si un nodo cae, el otro maneja el tráfico.</li>
            <li><strong>Pre-Producción (2 nodos):</strong> Replica producción para testing realista de performance y escalado.</li>
            <li><strong>Desarrollo (1 nodo fraccionado):</strong> Ahorro de costos dividiendo recursos entre Dev y QA en el mismo nodo.</li>
        </ul>
    </div>
</div>

<h2>9.2 Diagrama de Infraestructura Kubernetes</h2>

<div class="section">
    <div class="diagram">
        <div class="diagram-title">Arquitectura Completa de Kubernetes</div>
        <pre>
┌─────────────────────────────────────────────────────────────┐
│           CLOUD PROVIDER (AWS EKS / Azure AKS / GCP GKE)    │
└─────────────────────────────────────────────────────────────┘
                           │
      ┌────────────────────┼────────────────────┐
      │                    │                    │
┌─────▼──────────┐  ┌──────▼─────────┐  ┌──────▼──────────┐
│  NODO PROD 1   │  │  NODO PROD 2   │  │ NODO PRE-PROD 1 │
│  (Zona AZ-A)   │  │  (Zona AZ-B)   │  │  (Zona AZ-A)    │
├────────────────┤  ├────────────────┤  ├─────────────────┤
│                │  │                │  │                 │
│ ┌────────────┐ │  │ ┌────────────┐ │  │ ┌─────────────┐ │
│ │MS-Histórico│ │  │ │MS-Histórico│ │  │ │MS-Histórico │ │
│ │(Replica 1) │ │  │ │(Replica 2) │ │  │ │(Replica 1)  │ │
│ └────────────┘ │  │ └────────────┘ │  │ └─────────────┘ │
│                │  │                │  │                 │
│ ┌────────────┐ │  │ ┌────────────┐ │  │ ┌─────────────┐ │
│ │ MS-Pagos   │ │  │ │ MS-Pagos   │ │  │ │ MS-Pagos    │ │
│ │(Replica 1) │ │  │ │(Replica 2) │ │  │ │(Replica 1)  │ │
│ └────────────┘ │  │ └────────────┘ │  │ └─────────────┘ │
│                │  │                │  │                 │
│ ┌────────────┐ │  │ ┌────────────┐ │  │ ┌─────────────┐ │
│ │  MS-Auth   │ │  │ │  MS-Auth   │ │  │ │  MS-Auth    │ │
│ │(Replica 1) │ │  │ │(Replica 2) │ │  │ │(Replica 1)  │ │
│ └────────────┘ │  │ └────────────┘ │  │ └─────────────┘ │
│                │  │                │  │                 │
│ HPA: Enabled   │  │ HPA: Enabled   │  │ HPA: Enabled    │
│ Anti-affinity  │  │ Anti-affinity  │  │                 │
└────────────────┘  └────────────────┘  └─────────────────┘
      │                    │                    │
      └────────────────────┼────────────────────┘
                           │
                  ┌────────▼──────────┐
                  │  LOAD BALANCER    │
                  │ (Ingress Controller)│
                  │  - NGINX / Traefik │
                  │  - SSL Termination │
                  │  - Rate Limiting   │
                  └────────┬───────────┘
                           │
                  ┌────────▼──────────┐
                  │   INTERNET        │
                  │   (Usuarios)      │
                  └───────────────────┘
        </pre>
    </div>
</div>

<h2>9.3 Configuración de Autoescalado</h2>

<div class="section">
    <h3>9.3.1 Horizontal Pod Autoscaler (HPA)</h3>

    <p>Kubernetes escala pods automáticamente basado en métricas de uso:</p>

    <table>
        <thead>
            <tr>
                <th>Métrica</th>
                <th>Umbral Scale-Up</th>
                <th>Umbral Scale-Down</th>
                <th>Acción</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>CPU > 70%</strong></td>
                <td>5 min consecutivos</td>
                <td>CPU &lt; 30% por 10 min</td>
                <td>Crear nuevo pod</td>
            </tr>
            <tr>
                <td><strong>Memoria > 80%</strong></td>
                <td>3 min consecutivos</td>
                <td>Memoria &lt; 40% por 10 min</td>
                <td>Crear nuevo pod</td>
            </tr>
            <tr>
                <td><strong>Request Rate</strong></td>
                <td>&gt; 1000 req/s por pod</td>
                <td>&lt; 200 req/s por pod</td>
                <td>Ajustar réplicas</td>
            </tr>
        </tbody>
    </table>

    <div class="diagram">
        <div class="diagram-title">Límites de Escalado</div>
        <pre>
Por Servicio:
┌──────────────────────────────────────────────────────┐
│  Min Replicas: 2  (alta disponibilidad)             │
│  Max Replicas: 10 (control de costos)               │
│  Cool-down: 5 minutos (evitar flapping)             │
│  Scale-up velocity: 2 pods cada 30 segundos         │
│  Scale-down velocity: 1 pod cada 5 minutos          │
└──────────────────────────────────────────────────────┘

Ejemplo de Escalado Automático:
Carga Normal (100 req/s):     [Pod1] [Pod2]
Carga Alta (500 req/s):       [Pod1] [Pod2] [Pod3]
Pico (1500 req/s):           [Pod1] [Pod2] [Pod3] [Pod4] [Pod5]
De vuelta a normal:          [Pod1] [Pod2] (scale-down gradual)
        </pre>
    </div>

    <h3>9.3.2 Vertical Pod Autoscaler (VPA)</h3>

    <p>Ajusta automáticamente los recursos (CPU/RAM) asignados a cada pod según uso histórico:</p>

    <table>
        <thead>
            <tr>
                <th>Aspecto</th>
                <th>Comportamiento</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Análisis</strong></td>
                <td>Últimos 7 días de consumo de recursos</td>
            </tr>
            <tr>
                <td><strong>Recomendaciones</strong></td>
                <td>Ajusta requests y limits automáticamente</td>
            </tr>
            <tr>
                <td><strong>Aplicación</strong></td>
                <td>En ventanas de mantenimiento (bajo tráfico)</td>
            </tr>
            <tr>
                <td><strong>Modo</strong></td>
                <td>Recommendation (sugiere) o Auto (aplica automáticamente)</td>
            </tr>
        </tbody>
    </table>

    <div class="justification">
        <div class="justification-title">Beneficios del Autoescalado</div>
        <ul>
            <li><strong>Reducción de Costos:</strong> Solo se pagan recursos cuando se necesitan (40-60% ahorro vs aprovisionamiento estático)</li>
            <li><strong>Alta Disponibilidad:</strong> Escala automáticamente ante picos de tráfico (fin de mes, promociones)</li>
            <li><strong>Eficiencia Operativa:</strong> Sin intervención manual</li>
            <li><strong>Resiliencia:</strong> Maneja picos inesperados sin degradación</li>
        </ul>
    </div>
</div>

<h2>9.4 Balanceo de Carga</h2>

<div class="section">
    <h3>9.4.1 Algoritmo Recomendado: Least Connections</h3>

    <div class="justification">
        <div class="justification-title">¿Por qué Least Connections?</div>
        <p>Las transacciones bancarias tienen duración variable:</p>
        <ul>
            <li>Consultas simples: 50-100ms</li>
            <li>Transferencias: 500-2000ms</li>
            <li>Reportes: 2000-5000ms</li>
        </ul>
        <p>Least Connections distribuye mejor la carga real versus Round Robin, previniendo sobrecarga de pods individuales.</p>
    </div>

    <table>
        <thead>
            <tr>
                <th>Algoritmo</th>
                <th>Caso de Uso</th>
                <th>Pros</th>
                <th>Cons</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Least Connections</strong></td>
                <td>Default para todos los servicios</td>
                <td class="pros">Balanceo óptimo con requests de duración variable</td>
                <td>Overhead mínimo para tracking</td>
            </tr>
            <tr>
                <td><strong>IP Hash</strong></td>
                <td>Sesiones pegajosas (si necesario)</td>
                <td class="pros">Mantiene usuario en mismo pod</td>
                <td class="cons">Puede causar desbalanceo</td>
            </tr>
            <tr>
                <td><strong>Weighted Round Robin</strong></td>
                <td>Canary deployments</td>
                <td class="pros">Control fino para introducir nuevas versiones</td>
                <td>Requiere configuración manual</td>
            </tr>
        </tbody>
    </table>
</div>

<h2>9.5 Health Checking y Observabilidad</h2>

<div class="section">
    <h3>9.5.1 Health Checks en Kubernetes</h3>

    <table>
        <thead>
            <tr>
                <th>Tipo de Probe</th>
                <th>Pregunta</th>
                <th>Configuración</th>
                <th>Acción al Fallar</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Liveness Probe</strong></td>
                <td>¿El contenedor está vivo?</td>
                <td>
                    HTTP GET /health cada 10s<br>
                    Timeout: 3s<br>
                    Failure threshold: 3
                </td>
                <td>Reiniciar pod</td>
            </tr>
            <tr>
                <td><strong>Readiness Probe</strong></td>
                <td>¿El contenedor está listo para tráfico?</td>
                <td>
                    HTTP GET /ready cada 5s<br>
                    Timeout: 2s<br>
                    Success threshold: 1
                </td>
                <td>Remover del balanceador</td>
            </tr>
            <tr>
                <td><strong>Startup Probe</strong></td>
                <td>¿La aplicación terminó de iniciar?</td>
                <td>
                    HTTP GET /startup cada 5s<br>
                    Failure threshold: 30 (2.5 min)
                </td>
                <td>Reiniciar pod si falla</td>
            </tr>
        </tbody>
    </table>

    <h3>9.5.2 Implementación con ELK Stack</h3>

    <div class="diagram">
        <div class="diagram-title">Pipeline de Logs y Monitoreo</div>
        <pre>
┌──────────────────────────────────────────────┐
│          KUBERNETES CLUSTER                  │
│                                              │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  │
│  │  Pod     │  │  Pod     │  │  Pod     │  │
│  │          │  │          │  │          │  │
│  │ Filebeat │  │ Filebeat │  │ Filebeat │  │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘  │
└───────┼─────────────┼─────────────┼──────────┘
        │             │             │
        └─────────────┼─────────────┘
                      │ Ship Logs
           ┌──────────▼──────────┐
           │     LOGSTASH        │
           │  (Log Processing)   │
           │  - Parse            │
           │  - Filter           │
           │  - Enrich           │
           └──────────┬──────────┘
                      │
           ┌──────────▼──────────┐
           │   ELASTICSEARCH     │
           │   (Log Storage)     │
           │  - Índices por fecha│
           │  - Retención config │
           └──────────┬──────────┘
                      │
           ┌──────────▼──────────┐
           │      KIBANA         │
           │  (Visualization)    │
           │  - Dashboards       │
           │  - Alertas          │
           └─────────────────────┘
        </pre>
    </div>

    <h3>9.5.3 Métricas con Prometheus + Grafana</h3>

    <div class="diagram">
        <div class="diagram-title">Stack de Métricas</div>
        <pre>
┌──────────────────────────────────────────────┐
│       PROMETHEUS (Metrics Collection)        │
│                                              │
│  Scrape targets cada 15 segundos:            │
│  - /metrics endpoint en cada pod             │
│  - Node exporter (métricas del nodo)        │
│  - kube-state-metrics (estado K8s)          │
│                                              │
│  Retención: 30 días                          │
└──────────────────┬───────────────────────────┘
                   │
        ┌──────────▼──────────┐
        │     GRAFANA         │
        │  (Visualización)    │
        │                     │
        │  - Dashboards       │
        │  - Alertas          │
        │  - Query PromQL     │
        └─────────────────────┘
        </pre>
    </div>
</div>

<h2>9.6 Estrategia de Docker Compose</h2>

<div class="section">
    <p>Para desarrollo local y testing, se configuran múltiples archivos docker-compose agrupados por funcionalidad:</p>

    <h3>9.6.1 Estructura de Archivos</h3>

    <div class="diagram">
        <div class="diagram-title">Organización de Docker Compose</div>
        <pre>
docker/
├── docker-compose.core.yml           # Servicios core
├── docker-compose.databases.yml      # PostgreSQL, MongoDB, Redis
├── docker-compose.messaging.yml      # Kafka, ZooKeeper
├── docker-compose.observability.yml  # ELK, Prometheus, Grafana
├── docker-compose.dev.yml            # Override para desarrollo
└── docker-compose.test.yml           # Override para testing

<strong>Comando de inicio completo:</strong>
docker-compose \
  -f docker-compose.core.yml \
  -f docker-compose.databases.yml \
  -f docker-compose.messaging.yml \
  -f docker-compose.observability.yml \
  -f docker-compose.dev.yml \
  up -d
        </pre>
    </div>

    <h3>9.6.2 Beneficios de la Modularización</h3>

    <ul>
        <li><strong>Flexibilidad:</strong> Levantar solo servicios necesarios para testing específico</li>
        <li><strong>Mantenibilidad:</strong> Archivos pequeños y enfocados</li>
        <li><strong>Reutilización:</strong> Mismos archivos para dev, test y CI</li>
        <li><strong>Isolation:</strong> Servicios agrupados lógicamente</li>
    </ul>
</div>

<h2>9.7 Kafka + ZooKeeper para Bus de Mensajería</h2>

<div class="section">
    <h3>9.7.1 Configuración de Cluster</h3>

    <table>
        <thead>
            <tr>
                <th>Componente</th>
                <th>Configuración</th>
                <th>Justificación</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Kafka Brokers</strong></td>
                <td>3 nodos</td>
                <td>Alta disponibilidad y particionamiento</td>
            </tr>
            <tr>
                <td><strong>ZooKeeper Nodes</strong></td>
                <td>3 nodos (impar para quorum)</td>
                <td>Coordinación y failover automático</td>
            </tr>
            <tr>
                <td><strong>Replication Factor</strong></td>
                <td>3 para cada topic</td>
                <td>Tolerancia a fallo de 2 brokers</td>
            </tr>
            <tr>
                <td><strong>Min In-Sync Replicas</strong></td>
                <td>2</td>
                <td>Garantiza durabilidad sin sacrificar performance</td>
            </tr>
        </tbody>
    </table>

    <h3>9.7.2 Topics Principales</h3>

    <table>
        <thead>
            <tr>
                <th>Topic</th>
                <th>Particiones</th>
                <th>Retención</th>
                <th>Uso</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>transactions.created</strong></td>
                <td>10</td>
                <td>30 días</td>
                <td>Nuevas transacciones bancarias</td>
            </tr>
            <tr>
                <td><strong>audit.events</strong></td>
                <td>5</td>
                <td>7 años</td>
                <td>Eventos de auditoría (compliance)</td>
            </tr>
            <tr>
                <td><strong>notifications.queue</strong></td>
                <td>5</td>
                <td>7 días</td>
                <td>Notificaciones pendientes de envío</td>
            </tr>
            <tr>
                <td><strong>data.sync</strong></td>
                <td>3</td>
                <td>1 día</td>
                <td>Sincronización CQRS entre bases de datos</td>
            </tr>
            <tr>
                <td><strong>saga.orchestration</strong></td>
                <td>5</td>
                <td>3 días</td>
                <td>Coordinación de transacciones distribuidas</td>
            </tr>
        </tbody>
    </table>

    <div class="justification">
        <div class="justification-title">Justificación de Kafka</div>
        <ul>
            <li><strong>Throughput:</strong> 1M+ mensajes/segundo por nodo</li>
            <li><strong>Durabilidad:</strong> Réplicas + persistencia en disco</li>
            <li><strong>Escalabilidad:</strong> Particionamiento horizontal</li>
            <li><strong>Orden garantizado:</strong> Por partition key</li>
            <li><strong>Replay capability:</strong> Re-procesar eventos históricos</li>
        </ul>
    </div>
</div>

<h2>9.8 Opciones de Cloud Provider</h2>

<div class="section">
    <p>La arquitectura es agnóstica al proveedor cloud. Puede implementarse en cualquiera de las siguientes opciones:</p>

    <table>
        <thead>
            <tr>
                <th>Proveedor</th>
                <th>Servicio K8s</th>
                <th>Pros</th>
                <th>Cons</th>
                <th>Costo Estimado</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>AWS</strong></td>
                <td>EKS (Elastic Kubernetes Service)</td>
                <td>
                    <ul>
                        <li>Más maduro y estable</li>
                        <li>Amplia documentación</li>
                        <li>Integración con servicios AWS</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Curva de aprendizaje</li>
                        <li>Costos pueden escalar</li>
                    </ul>
                </td>
                <td>~$2,700/mes</td>
            </tr>
            <tr>
                <td><strong>Azure</strong></td>
                <td>AKS (Azure Kubernetes Service)</td>
                <td>
                    <ul>
                        <li>Control plane gratis</li>
                        <li>Integración con Azure AD</li>
                        <li>Buen soporte</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Menos maduro que EKS</li>
                        <li>Documentación menor</li>
                    </ul>
                </td>
                <td>~$2,400/mes</td>
            </tr>
            <tr>
                <td><strong>GCP</strong></td>
                <td>GKE (Google Kubernetes Engine)</td>
                <td>
                    <ul>
                        <li>Autopilot mode (managed)</li>
                        <li>Integración nativa con Kubernetes</li>
                        <li>Networking avanzado</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Menor adopción en LATAM</li>
                        <li>Soporte limitado local</li>
                    </ul>
                </td>
                <td>~$2,500/mes</td>
            </tr>
            <tr>
                <td><strong>OpenShift</strong></td>
                <td>OpenShift (Red Hat)</td>
                <td>
                    <ul>
                        <li>Kubernetes enterprise</li>
                        <li>Seguridad robusta</li>
                        <li>Soporte Red Hat</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Más costoso</li>
                        <li>Más complejo</li>
                    </ul>
                </td>
                <td>~$3,500/mes</td>
            </tr>
        </tbody>
    </table>

    <div class="success">
        <strong>Recomendación:</strong> AWS EKS por madurez, ecosistema y disponibilidad en LATAM. Alternativa viable: Azure AKS por costo/beneficio.
    </div>
</div>

<h2>9.9 Namespace Strategy</h2>

<div class="section">
    <h3>9.9.1 Organización por Namespaces</h3>

    <div class="diagram">
        <div class="diagram-title">Estructura de Namespaces</div>
        <pre>
┌──────────────────────────────────────────────────────┐
│           KUBERNETES CLUSTER                         │
├──────────────────────────────────────────────────────┤
│                                                      │
│  Namespace: production                               │
│  ├─ MS-Históricos (3 réplicas)                      │
│  ├─ MS-Pagos (3 réplicas)                           │
│  ├─ MS-Autenticación (3 réplicas)                   │
│  ├─ MS-Auditoría (2 réplicas)                       │
│  └─ API-Gateway (3 réplicas)                        │
│                                                      │
│  Namespace: pre-production                           │
│  ├─ MS-Históricos (2 réplicas)                      │
│  ├─ MS-Pagos (2 réplicas)                           │
│  ├─ MS-Autenticación (2 réplicas)                   │
│  └─ API-Gateway (2 réplicas)                        │
│                                                      │
│  Namespace: development                              │
│  ├─ MS-Históricos (1 réplica)                       │
│  ├─ MS-Pagos (1 réplica)                            │
│  └─ MS-Autenticación (1 réplica)                    │
│                                                      │
│  Namespace: qa                                       │
│  ├─ MS-Históricos (1 réplica)                       │
│  └─ MS-Pagos (1 réplica)                            │
│                                                      │
│  Namespace: monitoring                               │
│  ├─ Prometheus                                       │
│  ├─ Grafana                                          │
│  ├─ Elasticsearch                                    │
│  └─ Kibana                                           │
│                                                      │
│  Namespace: kube-system (sistema)                    │
│  ├─ kube-dns                                         │
│  ├─ metrics-server                                   │
│  └─ ingress-nginx                                    │
│                                                      │
└──────────────────────────────────────────────────────┘
        </pre>
    </div>

    <h3>9.9.2 Beneficios de Namespaces</h3>

    <ul>
        <li><strong>Aislamiento:</strong> Recursos de un ambiente no afectan otros</li>
        <li><strong>RBAC Granular:</strong> Permisos específicos por namespace</li>
        <li><strong>Resource Quotas:</strong> Límites de CPU/RAM por namespace</li>
        <li><strong>Network Policies:</strong> Control de tráfico entre namespaces</li>
        <li><strong>Organización:</strong> Separación lógica clara de ambientes</li>
    </ul>
</div>

<h2>9.10 Resource Quotas y Limits</h2>

<div class="section">
    <h3>9.10.1 Resource Requests y Limits por Microservicio</h3>

    <table>
        <thead>
            <tr>
                <th>Microservicio</th>
                <th>CPU Request</th>
                <th>CPU Limit</th>
                <th>Memory Request</th>
                <th>Memory Limit</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>MS-Históricos</strong></td>
                <td>0.5 cores</td>
                <td>2 cores</td>
                <td>1 GB</td>
                <td>4 GB</td>
            </tr>
            <tr>
                <td><strong>MS-Pagos</strong></td>
                <td>1 core</td>
                <td>2 cores</td>
                <td>2 GB</td>
                <td>4 GB</td>
            </tr>
            <tr>
                <td><strong>MS-Autenticación</strong></td>
                <td>0.5 cores</td>
                <td>1.5 cores</td>
                <td>1 GB</td>
                <td>3 GB</td>
            </tr>
            <tr>
                <td><strong>MS-Notificaciones</strong></td>
                <td>0.5 cores</td>
                <td>2 cores</td>
                <td>1 GB</td>
                <td>3 GB</td>
            </tr>
            <tr>
                <td><strong>MS-Auditoría</strong></td>
                <td>0.5 cores</td>
                <td>1.5 cores</td>
                <td>1 GB</td>
                <td>3 GB</td>
            </tr>
            <tr>
                <td><strong>API-Gateway</strong></td>
                <td>1 core</td>
                <td>2 cores</td>
                <td>2 GB</td>
                <td>4 GB</td>
            </tr>
        </tbody>
    </table>

    <div class="note">
        <strong>Diferencia entre Request y Limit:</strong>
        <ul>
            <li><strong>Request:</strong> Recursos garantizados que el pod siempre tendrá disponibles</li>
            <li><strong>Limit:</strong> Máximo de recursos que el pod puede usar (burst capacity)</li>
        </ul>
    </div>

    <h3>9.10.2 Namespace Resource Quotas</h3>

    <table>
        <thead>
            <tr>
                <th>Namespace</th>
                <th>CPU Total</th>
                <th>Memory Total</th>
                <th>Pods Máximos</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>production</strong></td>
                <td>30 cores</td>
                <td>60 GB</td>
                <td>100</td>
            </tr>
            <tr>
                <td><strong>pre-production</strong></td>
                <td>15 cores</td>
                <td>30 GB</td>
                <td>50</td>
            </tr>
            <tr>
                <td><strong>development</strong></td>
                <td>8 cores</td>
                <td>16 GB</td>
                <td>30</td>
            </tr>
            <tr>
                <td><strong>qa</strong></td>
                <td>8 cores</td>
                <td>16 GB</td>
                <td>30</td>
            </tr>
        </tbody>
    </table>
</div>

<h2>9.11 Network Policies</h2>

<div class="section">
    <h3>9.11.1 Segmentación de Red (Zero Trust)</h3>

    <p>Implementación de políticas de red para restringir comunicación entre pods:</p>

    <div class="diagram">
        <div class="diagram-title">Reglas de Network Policies</div>
        <pre>
Política por Defecto: DENY ALL
Solo se permiten comunicaciones explícitamente definidas

┌─────────────────────────────────────────────────────┐
│  Reglas Permitidas:                                 │
├─────────────────────────────────────────────────────┤
│                                                     │
│  ✓ Internet → API-Gateway (puerto 443)             │
│  ✓ API-Gateway → Cualquier microservicio           │
│  ✓ Microservicios → PostgreSQL (puerto 5432)       │
│  ✓ Microservicios → Redis (puerto 6379)            │
│  ✓ Microservicios → Kafka (puerto 9092)            │
│  ✓ Todos → Elasticsearch (puerto 9200)             │
│  ✓ Monitoring namespace → Todos (scraping)         │
│                                                     │
│  ✗ Microservicios NO pueden llamarse directamente  │
│     entre sí (deben pasar por API Gateway)         │
│  ✗ Internet NO puede acceder directamente a        │
│     microservicios (solo vía Gateway)              │
│  ✗ Namespace development NO puede acceder a        │
│     recursos de production                         │
│                                                     │
└─────────────────────────────────────────────────────┘
        </pre>
    </div>

    <h3>9.11.2 Beneficios de Network Policies</h3>

    <ul>
        <li><strong>Seguridad en profundidad:</strong> Limita blast radius de un compromiso</li>
        <li><strong>Compliance:</strong> Demuestra segmentación de red para auditorías</li>
        <li><strong>Zero Trust:</strong> Ninguna comunicación es confiable por defecto</li>
        <li><strong>Visibilidad:</strong> Políticas explícitas documentan arquitectura</li>
    </ul>
</div>

<h2>9.12 Ingress Controller</h2>

<div class="section">
    <h3>9.12.1 NGINX Ingress Controller</h3>

    <div class="justification">
        <div class="justification-title">¿Por qué NGINX Ingress?</div>
        <ul>
            <li><strong>Madurez:</strong> Estable y ampliamente adoptado</li>
            <li><strong>Performance:</strong> Maneja 50K+ requests/segundo</li>
            <li><strong>Features:</strong> SSL termination, rate limiting, redirects, rewrite rules</li>
            <li><strong>Integración:</strong> Cert-manager para SSL automático con Let's Encrypt</li>
        </ul>
    </div>

    <h3>9.12.2 Configuración de SSL/TLS</h3>

    <table>
        <thead>
            <tr>
                <th>Aspecto</th>
                <th>Configuración</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Protocolo</strong></td>
                <td>TLS 1.3 (fallback a TLS 1.2)</td>
            </tr>
            <tr>
                <td><strong>Certificados</strong></td>
                <td>Let's Encrypt (renovación automática cada 60 días)</td>
            </tr>
            <tr>
                <td><strong>Cipher Suites</strong></td>
                <td>Solo strong ciphers (AES-256-GCM, ChaCha20)</td>
            </tr>
            <tr>
                <td><strong>HSTS</strong></td>
                <td>Enabled (max-age=31536000)</td>
            </tr>
            <tr>
                <td><strong>Certificate Pinning</strong></td>
                <td>Configurado en apps móviles</td>
            </tr>
        </tbody>
    </table>

    <h3>9.12.3 Rate Limiting en Ingress</h3>

    <table>
        <thead>
            <tr>
                <th>Endpoint</th>
                <th>Rate Limit</th>
                <th>Burst</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>/api/v1/login</strong></td>
                <td>5 req/min por IP</td>
                <td>10</td>
            </tr>
            <tr>
                <td><strong>/api/v1/register</strong></td>
                <td>3 req/hora por IP</td>
                <td>5</td>
            </tr>
            <tr>
                <td><strong>/graphql</strong></td>
                <td>100 req/min por usuario</td>
                <td>150</td>
            </tr>
            <tr>
                <td><strong>Global</strong></td>
                <td>1000 req/min por IP</td>
                <td>1500</td>
            </tr>
        </tbody>
    </table>
</div>

<h2>9.13 Persistent Storage</h2>

<div class="section">
    <h3>9.13.1 Storage Classes</h3>

    <table>
        <thead>
            <tr>
                <th>Storage Class</th>
                <th>Tipo</th>
                <th>Performance</th>
                <th>Uso</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>ssd-fast</strong></td>
                <td>SSD (gp3 en AWS)</td>
                <td>Alta (3000 IOPS)</td>
                <td>Bases de datos transaccionales</td>
            </tr>
            <tr>
                <td><strong>ssd-standard</strong></td>
                <td>SSD (gp2 en AWS)</td>
                <td>Media (baseline IOPS)</td>
                <td>Redis, aplicaciones generales</td>
            </tr>
            <tr>
                <td><strong>hdd-bulk</strong></td>
                <td>HDD (st1 en AWS)</td>
                <td>Baja (throughput optimized)</td>
                <td>Logs, backups, archivos</td>
            </tr>
        </tbody>
    </table>

    <h3>9.13.2 Persistent Volume Claims</h3>

    <table>
        <thead>
            <tr>
                <th>Componente</th>
                <th>Storage Class</th>
                <th>Tamaño</th>
                <th>ReclaimPolicy</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>PostgreSQL Primary</strong></td>
                <td>ssd-fast</td>
                <td>500 GB</td>
                <td>Retain (manual deletion)</td>
            </tr>
            <tr>
                <td><strong>PostgreSQL Replicas</strong></td>
                <td>ssd-fast</td>
                <td>500 GB</td>
                <td>Retain</td>
            </tr>
            <tr>
                <td><strong>Redis</strong></td>
                <td>ssd-standard</td>
                <td>100 GB</td>
                <td>Delete</td>
            </tr>
            <tr>
                <td><strong>Kafka</strong></td>
                <td>ssd-standard</td>
                <td>1 TB</td>
                <td>Retain</td>
            </tr>
            <tr>
                <td><strong>Elasticsearch</strong></td>
                <td>ssd-standard</td>
                <td>2 TB</td>
                <td>Retain</td>
            </tr>
        </tbody>
    </table>
</div>

<h2>9.14 Secrets Management</h2>

<div class="section">
    <h3>9.14.1 HashiCorp Vault Integration</h3>

    <p>Kubernetes se integra con Vault para inyección de secretos:</p>

    <div class="diagram">
        <div class="diagram-title">Flujo de Secrets Injection</div>
        <pre>
1. Pod inicia en Kubernetes
   │
   ▼
2. Init Container ejecuta Vault Agent
   │
   ├─► Autentica con Vault usando Service Account
   ├─► Obtiene secretos (DB passwords, API keys)
   └─► Escribe secretos en volumen compartido
   │
   ▼
3. Contenedor principal inicia
   │
   └─► Lee secretos desde volumen
       (NO desde variables de entorno)
   │
   ▼
4. Vault Agent Sidecar (opcional)
   │
   └─► Renueva secretos automáticamente
       └─► Refresca cada 1 hora
        </pre>
    </div>

    <h3>9.14.2 Tipos de Secretos Gestionados</h3>

    <ul>
        <li><strong>Database Credentials:</strong> PostgreSQL, Redis passwords</li>
        <li><strong>API Keys:</strong> Firebase, servicios externos</li>
        <li><strong>JWT Signing Keys:</strong> Para autenticación OAuth</li>
        <li><strong>Encryption Keys:</strong> Para datos sensibles</li>
        <li><strong>SSL Certificates:</strong> Para comunicación interna</li>
    </ul>

    <div class="warning">
        <strong>Nunca almacenar secretos en:</strong>
        <ul>
            <li>Variables de entorno en Kubernetes manifests</li>
            <li>ConfigMaps (son plain text)</li>
            <li>Git repositories</li>
            <li>Docker images</li>
        </ul>
    </div>
</div>

<h2>9.15 CI/CD Pipeline para Kubernetes</h2>

<div class="section">
    <h3>9.15.1 Pipeline Automatizado</h3>

    <div class="diagram">
        <div class="diagram-title">Flujo CI/CD Completo</div>
        <pre>
1. Developer Push → Git (GitHub/GitLab)
   │
   ▼
2. CI Pipeline Triggered
   │
   ├─► Lint & Type Check
   ├─► Unit Tests
   ├─► Integration Tests
   └─► Security Scan (Snyk, Trivy)
   │
   ▼
3. Build Docker Image
   │
   ├─► Multi-stage build (optimized)
   ├─► Tag: git-sha + semantic version
   └─► Push to Container Registry (ECR/ACR/GCR)
   │
   ▼
4. Deploy to Development (automatic)
   │
   ├─► kubectl apply -f k8s/dev/
   ├─► Wait for rollout complete
   └─► Run smoke tests
   │
   ▼
5. Deploy to Pre-Production (manual approval)
   │
   ├─► kubectl apply -f k8s/staging/
   ├─► Run E2E tests
   └─► Performance tests
   │
   ▼
6. Deploy to Production (manual approval)
   │
   ├─► Blue-Green deployment strategy
   ├─► Deploy to "green" environment
   ├─► Run health checks (5 min)
   ├─► Switch traffic to "green"
   └─► Monitor error rate (15 min window)
       │
       ├─► [Si error rate > 1%] → Automatic rollback
       └─► [Si OK] → Complete deployment
        </pre>
    </div>

    <h3>9.15.2 Deployment Strategies</h3>

    <table>
        <thead>
            <tr>
                <th>Estrategia</th>
                <th>Uso</th>
                <th>Pros</th>
                <th>Cons</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Rolling Update</strong></td>
                <td>Updates normales</td>
                <td class="pros">Zero downtime, gradual</td>
                <td>Dos versiones coexistiendo temporalmente</td>
            </tr>
            <tr>
                <td><strong>Blue-Green</strong></td>
                <td>Releases mayores</td>
                <td class="pros">Rollback instantáneo, testing completo</td>
                <td class="cons">Requiere 2x recursos temporalmente</td>
            </tr>
            <tr>
                <td><strong>Canary</strong></td>
                <td>Features de alto riesgo</td>
                <td class="pros">Exposición gradual (5% → 100%)</td>
                <td>Requiere feature flags</td>
            </tr>
        </tbody>
    </table>
</div>

<h2>9.16 Backup y Disaster Recovery</h2>

<div class="section">
    <h3>9.16.1 Backup de Configuraciones</h3>

    <table>
        <thead>
            <tr>
                <th>Componente</th>
                <th>Método de Backup</th>
                <th>Frecuencia</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Kubernetes Manifests</strong></td>
                <td>Git repository (GitOps)</td>
                <td>Cada commit (versionado)</td>
            </tr>
            <tr>
                <td><strong>etcd (K8s state)</strong></td>
                <td>Velero snapshots</td>
                <td>Cada 6 horas</td>
            </tr>
            <tr>
                <td><strong>Persistent Volumes</strong></td>
                <td>Volume snapshots (cloud provider)</td>
                <td>Diario</td>
            </tr>
            <tr>
                <td><strong>Secrets (Vault)</strong></td>
                <td>Vault snapshots</td>
                <td>Diario</td>
            </tr>
        </tbody>
    </table>

    <h3>9.16.2 Plan de Disaster Recovery</h3>

    <table>
        <thead>
            <tr>
                <th>Escenario</th>
                <th>RTO</th>
                <th>RPO</th>
                <th>Procedimiento</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Pod crash</strong></td>
                <td>&lt; 30 segundos</td>
                <td>0</td>
                <td>K8s reinicia automáticamente</td>
            </tr>
            <tr>
                <td><strong>Node failure</strong></td>
                <td>&lt; 5 minutos</td>
                <td>0</td>
                <td>K8s reschedula pods en otros nodos</td>
            </tr>
            <tr>
                <td><strong>Zona AZ completa</strong></td>
                <td>&lt; 5 minutos</td>
                <td>0</td>
                <td>Réplicas en otras AZ asumen carga</td>
            </tr>
            <tr>
                <td><strong>Cluster completo</strong></td>
                <td>&lt; 2 horas</td>
                <td>&lt; 6 horas</td>
                <td>Restaurar desde Velero backup + DB restore</td>
            </tr>
            <tr>
                <td><strong>Región completa</strong></td>
                <td>&lt; 6 horas</td>
                <td>&lt; 1 día</td>
                <td>Failover a región secundaria (geo-replication)</td>
            </tr>
        </tbody>
    </table>
</div>

<h2>9.17 Estimación de Costos</h2>

<div class="section">
    <h3>9.17.1 Costos Mensuales Estimados (AWS EKS)</h3>

    <table>
        <thead>
            <tr>
                <th>Componente</th>
                <th>Especificación</th>
                <th>Costo Mensual (USD)</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>EKS Control Plane</strong></td>
                <td>1 cluster</td>
                <td>$73</td>
            </tr>
            <tr>
                <td><strong>Nodos EC2 Producción</strong></td>
                <td>2x t3.xlarge (4vCPU, 16GB)</td>
                <td>$300</td>
            </tr>
            <tr>
                <td><strong>Nodos EC2 Pre-Prod</strong></td>
                <td>2x t3.large (2vCPU, 8GB)</td>
                <td>$150</td>
            </tr>
            <tr>
                <td><strong>Nodos EC2 Dev</strong></td>
                <td>1x t3.medium (2vCPU, 4GB)</td>
                <td>$40</td>
            </tr>
            <tr>
                <td><strong>Load Balancer</strong></td>
                <td>Application LB</td>
                <td>$25</td>
            </tr>
            <tr>
                <td><strong>EBS Volumes</strong></td>
                <td>5 TB SSD (gp3)</td>
                <td>$400</td>
            </tr>
            <tr>
                <td><strong>NAT Gateway</strong></td>
                <td>2 AZ</td>
                <td>$90</td>
            </tr>
            <tr>
                <td><strong>Data Transfer</strong></td>
                <td>1 TB egress</td>
                <td>$90</td>
            </tr>
            <tr>
                <td><strong>Backup Storage</strong></td>
                <td>1 TB S3 Glacier</td>
                <td>$15</td>
            </tr>
            <tr>
                <td><strong>CloudWatch Logs</strong></td>
                <td>50 GB/mes</td>
                <td>$30</td>
            </tr>
            <tr>
                <td><strong>Route 53</strong></td>
                <td>Hosted zone + queries</td>
                <td>$10</td>
            </tr>
        </tbody>
    </table>

    <div class="success">
        <strong>Total Estimado (solo K8s infra): ~$1,223/mes</strong><br>
        <strong>Total con bases de datos y servicios adicionales: ~$2,700/mes</strong>
    </div>

    <h3>9.17.2 Optimizaciones de Costo</h3>

    <ul>
        <li><strong>Reserved Instances:</strong> 40-60% descuento comprando 1-3 años → Ahorro $400/mes</li>
        <li><strong>Spot Instances para Dev/QA:</strong> 70-90% descuento → Ahorro $80/mes</li>
        <li><strong>S3 Lifecycle policies:</strong> Mover logs antiguos a Glacier → Ahorro $50/mes</li>
        <li><strong>Right-sizing:</strong> Análisis mensual de uso → Ahorro 15-25%</li>
    </ul>

    <div class="success">
        <strong>Costo Optimizado: ~$2,000/mes (~$24,000/año)</strong>
    </div>
</div>

<div class="success">
    <h3>✅ Resumen del Capítulo</h3>
    <p>La infraestructura en Kubernetes propuesta ofrece:</p>
    <ul>
        <li><strong>Multi-ambiente:</strong> Producción (2 nodos), Pre-prod (2 nodos), Dev (1 nodo)</li>
        <li><strong>Alta disponibilidad:</strong> Réplicas en múltiples AZ, anti-affinity rules</li>
        <li><strong>Autoescalado:</strong> HPA + VPA para eficiencia de costos (40-60% ahorro)</li>
        <li><strong>Seguridad:</strong> Network policies, secrets en Vault, RBAC granular</li>
        <li><strong>Observabilidad:</strong> ELK Stack + Prometheus + Grafana</li>
        <li><strong>CI/CD automatizado:</strong> Blue-green deployments, rollback automático</li>
        <li><strong>Disaster Recovery:</strong> RTO &lt; 2 horas, backups automatizados</li>
        <li><strong>Agnóstico al proveedor:</strong> Funciona en AWS, Azure, GCP u OpenShift</li>
        <li><strong>Costo optimizado:</strong> ~$2,000/mes con optimizaciones vs $3,000+ sin ellas</li>
    </ul>
    <p><strong>Recomendación:</strong> AWS EKS con Reserved Instances para producción y Spot Instances para dev/QA.</p>
</div>

<div class="footer">
    <p>Propuesta de Arquitectura - Sistema Bancario BP | Capítulo 9 de 17</p>
</div>

</body>
</html>