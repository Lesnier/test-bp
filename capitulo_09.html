<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
      Capítulo 9 - Infraestructura Cloud y Orquestación con Kubernetes
    </title>
    <link rel="stylesheet" href="styles.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.6.1/mermaid.min.js"></script>
    <script>
      mermaid.initialize({
        startOnLoad: true,
        theme: "base",
        themeVariables: {
          primaryColor: "#E8F5E9",
          primaryTextColor: "#2C3E50",
          primaryBorderColor: "#4CAF50",
          lineColor: "#34495E",
          secondaryColor: "#E3F2FD",
          tertiaryColor: "#FFF9C4",
          noteBkgColor: "#FFE5E5",
          noteBorderColor: "#E74C3C",
          fontSize: "14px",
        },
      });
    </script>
  </head>
  <body>
    <div class="nav-header">
      <h2>Capítulo 9: Infraestructura Cloud y Orquestación con Kubernetes</h2>
      <div class="nav-buttons">
        <a href="capitulo_08.html" class="nav-btn">← Anterior</a>
        <a href="index.html" class="nav-btn">Índice</a>
        <a href="capitulo_10.html" class="nav-btn">Siguiente →</a>
      </div>
    </div>

    <h1>9. INFRAESTRUCTURA CLOUD Y ORQUESTACIÓN CON KUBERNETES</h1>

    <h2>9.1 Estrategia de Despliegue Multi-Ambiente</h2>

    <div class="section">
      <p>
        El sistema se desplegará en Kubernetes con
        <strong>3 ambientes separados</strong> para garantizar aislamiento y
        permitir testing exhaustivo antes de llegar a producción.
      </p>

      <table>
        <thead>
          <tr>
            <th>Ambiente</th>
            <th>Nodos</th>
            <th>Pods por Servicio</th>
            <th>CPU/RAM por Pod</th>
            <th>Propósito</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Producción</strong></td>
            <td>2 nodos</td>
            <td>3 réplicas</td>
            <td>2 CPU / 4GB RAM</td>
            <td>Usuarios finales, 99.9% uptime</td>
          </tr>
          <tr>
            <td><strong>Pre-Producción</strong></td>
            <td>2 nodos</td>
            <td>2 réplicas</td>
            <td>1 CPU / 2GB RAM</td>
            <td>Testing final, staging, validación</td>
          </tr>
          <tr>
            <td><strong>Desarrollo</strong></td>
            <td>1 nodo</td>
            <td>2 pods (Dev + QA)</td>
            <td>0.5 CPU / 1GB RAM</td>
            <td>Desarrollo activo, testing de features</td>
          </tr>
        </tbody>
      </table>

      <div class="justification">
        <div class="justification-title">Justificación de la Estrategia</div>
        <ul>
          <li>
            <strong>Producción (2 nodos):</strong> Alta disponibilidad con
            anti-affinity rules. Si un nodo cae, el otro maneja el tráfico.
          </li>
          <li>
            <strong>Pre-Producción (2 nodos):</strong> Replica producción para
            testing realista de performance y escalado.
          </li>
          <li>
            <strong>Desarrollo (1 nodo fraccionado):</strong> Ahorro de costos
            dividiendo recursos entre Dev y QA en el mismo nodo.
          </li>
        </ul>
      </div>
    </div>

    <h2>9.2 Diagrama de Infraestructura Kubernetes</h2>

    <div class="section">
      <div class="diagram">
        <div class="diagram-title">Arquitectura Completa de Kubernetes</div>
        <pre class="mermaid">
graph TB
    Cloud["<b>CLOUD PROVIDER</b><br/>(AWS EKS / Azure AKS / GCP GKE)"]
    
    subgraph NodeProd1["<b>NODO PROD 1</b><br/>(Zona AZ-A)"]
        MSH1["MS-Histórico<br/>(Replica 1)"]
        MSP1["MS-Pagos<br/>(Replica 1)"]
        MSA1["MS-Auth<br/>(Replica 1)"]
        HPA1["HPA: Enabled<br/>Anti-affinity"]
    end
    
    subgraph NodeProd2["<b>NODO PROD 2</b><br/>(Zona AZ-B)"]
        MSH2["MS-Histórico<br/>(Replica 2)"]
        MSP2["MS-Pagos<br/>(Replica 2)"]
        MSA2["MS-Auth<br/>(Replica 2)"]
        HPA2["HPA: Enabled<br/>Anti-affinity"]
    end
    
    subgraph NodePreProd["<b>NODO PRE-PROD 1</b><br/>(Zona AZ-A)"]
        MSHPP["MS-Histórico<br/>(Replica 1)"]
        MSPPP["MS-Pagos<br/>(Replica 1)"]
        MSAPP["MS-Auth<br/>(Replica 1)"]
        HPAPP["HPA: Enabled"]
    end
    
    LB["<b>LOAD BALANCER</b><br/>(Ingress Controller)<br/>- NGINX / Traefik<br/>- SSL Termination<br/>- Rate Limiting"]
    
    Internet["<b>INTERNET</b><br/>(Usuarios)"]
    
    Cloud --> NodeProd1
    Cloud --> NodeProd2
    Cloud --> NodePreProd
    
    NodeProd1 --> LB
    NodeProd2 --> LB
    NodePreProd --> LB
    
    LB --> Internet
    
    style Cloud fill:#E3F2FD,stroke:#2196F3,stroke-width:3px,rx:15,ry:15
    style NodeProd1 fill:#E8F5E9,stroke:#4CAF50,stroke-width:3px,rx:15,ry:15
    style NodeProd2 fill:#E8F5E9,stroke:#4CAF50,stroke-width:3px,rx:15,ry:15
    style NodePreProd fill:#FFF9C4,stroke:#FBC02D,stroke-width:3px,rx:15,ry:15
    style LB fill:#FFE5E5,stroke:#E74C3C,stroke-width:3px,rx:15,ry:15
    style Internet fill:#F3E5F5,stroke:#9C27B0,stroke-width:3px,rx:15,ry:15
        </pre>
      </div>
    </div>

    <h2>9.3 Configuración de Autoescalado</h2>

    <div class="section">
      <h3>9.3.1 Horizontal Pod Autoscaler (HPA)</h3>

      <p>Kubernetes escala pods automáticamente basado en métricas de uso:</p>

      <table>
        <thead>
          <tr>
            <th>Métrica</th>
            <th>Umbral Scale-Up</th>
            <th>Umbral Scale-Down</th>
            <th>Acción</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>CPU > 70%</strong></td>
            <td>5 min consecutivos</td>
            <td>CPU &lt; 30% por 10 min</td>
            <td>Crear nuevo pod</td>
          </tr>
          <tr>
            <td><strong>Memoria > 80%</strong></td>
            <td>3 min consecutivos</td>
            <td>Memoria &lt; 40% por 10 min</td>
            <td>Crear nuevo pod</td>
          </tr>
          <tr>
            <td><strong>Request Rate</strong></td>
            <td>&gt; 1000 req/s por pod</td>
            <td>&lt; 200 req/s por pod</td>
            <td>Ajustar réplicas</td>
          </tr>
        </tbody>
      </table>

      <div class="diagram">
        <div class="diagram-title">Límites de Escalado</div>
        <pre class="mermaid">
flowchart TB
    Config["<b>Configuración por Servicio</b>"]
    
    subgraph Limits["<b>Límites de Escalado</b>"]
        MinRep["Min Replicas: 2<br/>(alta disponibilidad)"]
        MaxRep["Max Replicas: 10<br/>(control de costos)"]
        Cooldown["Cool-down: 5 minutos<br/>(evitar flapping)"]
        ScaleUp["Scale-up velocity:<br/>2 pods cada 30 segundos"]
        ScaleDown["Scale-down velocity:<br/>1 pod cada 5 minutos"]
    end
    
    subgraph Examples["<b>Ejemplos de Escalado</b>"]
        Normal["Carga Normal (100 req/s)<br/>[Pod1] [Pod2]"]
        High["Carga Alta (500 req/s)<br/>[Pod1] [Pod2] [Pod3]"]
        Peak["Pico (1500 req/s)<br/>[Pod1] [Pod2] [Pod3]<br/>[Pod4] [Pod5]"]
        Return["De vuelta a normal<br/>[Pod1] [Pod2]<br/>(scale-down gradual)"]
    end
    
    Config --> Limits
    Limits --> Examples
    
    Normal --> High
    High --> Peak
    Peak --> Return
    
    style Config fill:#E3F2FD,stroke:#2196F3,stroke-width:3px,rx:15,ry:15
    style Limits fill:#E8F5E9,stroke:#4CAF50,stroke-width:3px,rx:15,ry:15
    style Examples fill:#FFF9C4,stroke:#FBC02D,stroke-width:3px,rx:15,ry:15
    style Normal fill:#F3E5F5,stroke:#9C27B0,stroke-width:2px,rx:10,ry:10
    style High fill:#FFE5E5,stroke:#E74C3C,stroke-width:2px,rx:10,ry:10
    style Peak fill:#FFEBEE,stroke:#C62828,stroke-width:2px,rx:10,ry:10
    style Return fill:#E8F5E9,stroke:#4CAF50,stroke-width:2px,rx:10,ry:10
        </pre>
      </div>

      <h3>9.3.2 Vertical Pod Autoscaler (VPA)</h3>

      <p>
        Ajusta automáticamente los recursos (CPU/RAM) asignados a cada pod según
        uso histórico:
      </p>

      <table>
        <thead>
          <tr>
            <th>Aspecto</th>
            <th>Comportamiento</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Análisis</strong></td>
            <td>Últimos 7 días de consumo de recursos</td>
          </tr>
          <tr>
            <td><strong>Recomendaciones</strong></td>
            <td>Ajusta requests y limits automáticamente</td>
          </tr>
          <tr>
            <td><strong>Aplicación</strong></td>
            <td>En ventanas de mantenimiento (bajo tráfico)</td>
          </tr>
          <tr>
            <td><strong>Modo</strong></td>
            <td>Recommendation (sugiere) o Auto (aplica automáticamente)</td>
          </tr>
        </tbody>
      </table>

      <div class="justification">
        <div class="justification-title">Beneficios del Autoescalado</div>
        <ul>
          <li>
            <strong>Reducción de Costos:</strong> Solo se pagan recursos cuando
            se necesitan (40-60% ahorro vs aprovisionamiento estático)
          </li>
          <li>
            <strong>Alta Disponibilidad:</strong> Escala automáticamente ante
            picos de tráfico (fin de mes, promociones)
          </li>
          <li>
            <strong>Eficiencia Operativa:</strong> Sin intervención manual
          </li>
          <li>
            <strong>Resiliencia:</strong> Maneja picos inesperados sin
            degradación
          </li>
        </ul>
      </div>
    </div>

    <h2>9.4 Balanceo de Carga</h2>

    <div class="section">
      <h3>9.4.1 Algoritmo Recomendado: Least Connections</h3>

      <div class="justification">
        <div class="justification-title">¿Por qué Least Connections?</div>
        <p>Las transacciones bancarias tienen duración variable:</p>
        <ul>
          <li>Consultas simples: 50-100ms</li>
          <li>Transferencias: 500-2000ms</li>
          <li>Reportes: 2000-5000ms</li>
        </ul>
        <p>
          Least Connections distribuye mejor la carga real versus Round Robin,
          previniendo sobrecarga de pods individuales.
        </p>
      </div>

      <table>
        <thead>
          <tr>
            <th>Algoritmo</th>
            <th>Caso de Uso</th>
            <th>Pros</th>
            <th>Cons</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Least Connections</strong></td>
            <td>Default para todos los servicios</td>
            <td class="pros">
              Balanceo óptimo con requests de duración variable
            </td>
            <td>Overhead mínimo para tracking</td>
          </tr>
          <tr>
            <td><strong>IP Hash</strong></td>
            <td>Sesiones pegajosas (si necesario)</td>
            <td class="pros">Mantiene usuario en mismo pod</td>
            <td class="cons">Puede causar desbalanceo</td>
          </tr>
          <tr>
            <td><strong>Weighted Round Robin</strong></td>
            <td>Canary deployments</td>
            <td class="pros">Control fino para introducir nuevas versiones</td>
            <td>Requiere configuración manual</td>
          </tr>
        </tbody>
      </table>
    </div>

    <h2>9.5 Health Checking y Observabilidad</h2>

    <div class="section">
      <h3>9.5.1 Health Checks en Kubernetes</h3>

      <table>
        <thead>
          <tr>
            <th>Tipo de Probe</th>
            <th>Pregunta</th>
            <th>Configuración</th>
            <th>Acción al Fallar</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Liveness Probe</strong></td>
            <td>¿El contenedor está vivo?</td>
            <td>
              HTTP GET /health cada 10s<br />
              Timeout: 3s<br />
              Failure threshold: 3
            </td>
            <td>Reiniciar pod</td>
          </tr>
          <tr>
            <td><strong>Readiness Probe</strong></td>
            <td>¿El contenedor está listo para tráfico?</td>
            <td>
              HTTP GET /ready cada 5s<br />
              Timeout: 2s<br />
              Success threshold: 1
            </td>
            <td>Remover del balanceador</td>
          </tr>
          <tr>
            <td><strong>Startup Probe</strong></td>
            <td>¿La aplicación terminó de iniciar?</td>
            <td>
              HTTP GET /startup cada 5s<br />
              Failure threshold: 30 (2.5 min)
            </td>
            <td>Reiniciar pod si falla</td>
          </tr>
        </tbody>
      </table>

      <h3>9.5.2 Implementación con ELK Stack</h3>

      <div class="diagram">
        <div class="diagram-title">Pipeline de Logs y Monitoreo</div>
        <pre class="mermaid">
flowchart TD
    subgraph K8sCluster["<b>KUBERNETES CLUSTER</b>"]
        Pod1["Pod<br/>Filebeat"]
        Pod2["Pod<br/>Filebeat"]
        Pod3["Pod<br/>Filebeat"]
    end
    
    Logstash["<b>LOGSTASH</b><br/>(Log Processing)<br/><br/>• Parse<br/>• Filter<br/>• Enrich"]
    
    Elasticsearch["<b>ELASTICSEARCH</b><br/>(Log Storage)<br/><br/>• Índices por fecha<br/>• Retención config"]
    
    Kibana["<b>KIBANA</b><br/>(Visualization)<br/><br/>• Dashboards<br/>• Alertas"]
    
    Pod1 --> Logstash
    Pod2 --> Logstash
    Pod3 --> Logstash
    
    Logstash --> Elasticsearch
    Elasticsearch --> Kibana
    
    style K8sCluster fill:#E3F2FD,stroke:#2196F3,stroke-width:3px,rx:15,ry:15
    style Logstash fill:#FFF9C4,stroke:#FBC02D,stroke-width:3px,rx:15,ry:15
    style Elasticsearch fill:#E8F5E9,stroke:#4CAF50,stroke-width:3px,rx:15,ry:15
    style Kibana fill:#FFE5E5,stroke:#E74C3C,stroke-width:3px,rx:15,ry:15
        </pre>
      </div>

      <h3>9.5.3 Métricas con Prometheus + Grafana</h3>

      <div class="diagram">
        <div class="diagram-title">Stack de Métricas</div>
        <pre class="mermaid">
flowchart TD
    subgraph Prometheus["<b>PROMETHEUS</b><br/>(Metrics Collection)"]
        direction TB
        Scrape["Scrape targets cada 15s:<br/>• /metrics endpoint<br/>• Node exporter<br/>• kube-state-metrics"]
        Retention["Retención: 30 días"]
    end
    
    Grafana["<b>GRAFANA</b><br/>(Visualización)<br/><br/>• Dashboards<br/>• Alertas<br/>• Query PromQL"]
    
    Prometheus --> Grafana
    
    style Prometheus fill:#E8F5E9,stroke:#4CAF50,stroke-width:3px,rx:15,ry:15
    style Grafana fill:#E3F2FD,stroke:#2196F3,stroke-width:3px,rx:15,ry:15
        </pre>
      </div>
    </div>

    <h2>9.6 Estrategia de Docker Compose</h2>

    <div class="section">
      <p>
        Para desarrollo local y testing, se configuran múltiples archivos
        docker-compose agrupados por funcionalidad:
      </p>

      <h3>9.6.1 Estructura de Archivos</h3>

      <div class="diagram">
        <div class="diagram-title">Organización de Docker Compose</div>
        <pre class="mermaid">
graph TB
    Root[docker/]
    
    Core[docker-compose.core.yml<br/>Servicios core]
    DB[docker-compose.databases.yml<br/>PostgreSQL, MongoDB, Redis]
    Msg[docker-compose.messaging.yml<br/>Kafka, ZooKeeper]
    Obs[docker-compose.observability.yml<br/>ELK, Prometheus, Grafana]
    Dev[docker-compose.dev.yml<br/>Override para desarrollo]
    Test[docker-compose.test.yml<br/>Override para testing]
    
    Command["<b>Comando de inicio completo:</b><br/><br/>docker-compose \<br/>-f docker-compose.core.yml \<br/>-f docker-compose.databases.yml \<br/>-f docker-compose.messaging.yml \<br/>-f docker-compose.observability.yml \<br/>-f docker-compose.dev.yml \<br/>up -d"]
    
    Root --> Core
    Root --> DB
    Root --> Msg
    Root --> Obs
    Root --> Dev
    Root --> Test
    
    Core --> Command
    DB --> Command
    Msg --> Command
    Obs --> Command
    Dev --> Command
    
    style Root fill:#E3F2FD,stroke:#2196F3,stroke-width:3px,rx:15,ry:15
    style Core fill:#E8F5E9,stroke:#4CAF50,stroke-width:3px,rx:15,ry:15
    style DB fill:#FFF9C4,stroke:#FBC02D,stroke-width:3px,rx:15,ry:15
    style Msg fill:#FFE5E5,stroke:#E74C3C,stroke-width:3px,rx:15,ry:15
    style Obs fill:#F3E5F5,stroke:#9C27B0,stroke-width:3px,rx:15,ry:15
    style Dev fill:#E0F2F1,stroke:#00897B,stroke-width:3px,rx:15,ry:15
    style Test fill:#FFF3E0,stroke:#F57C00,stroke-width:3px,rx:15,ry:15
    style Command fill:#FCE4EC,stroke:#C2185B,stroke-width:3px,rx:15,ry:15
        </pre>
      </div>

      <h3>9.6.2 Beneficios de la Modularización</h3>

      <ul>
        <li>
          <strong>Flexibilidad:</strong> Levantar solo servicios necesarios para
          testing específico
        </li>
        <li><strong>Mantenibilidad:</strong> Archivos pequeños y enfocados</li>
        <li>
          <strong>Reutilización:</strong> Mismos archivos para dev, test y CI
        </li>
        <li><strong>Isolation:</strong> Servicios agrupados lógicamente</li>
      </ul>
    </div>

    <h2>9.7 Kafka + ZooKeeper para Bus de Mensajería</h2>

    <div class="section">
      <h3>9.7.1 Configuración de Cluster</h3>

      <table>
        <thead>
          <tr>
            <th>Componente</th>
            <th>Configuración</th>
            <th>Justificación</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Kafka Brokers</strong></td>
            <td>3 nodos</td>
            <td>Alta disponibilidad y particionamiento</td>
          </tr>
          <tr>
            <td><strong>ZooKeeper Nodes</strong></td>
            <td>3 nodos (impar para quorum)</td>
            <td>Coordinación y failover automático</td>
          </tr>
          <tr>
            <td><strong>Replication Factor</strong></td>
            <td>3 para cada topic</td>
            <td>Tolerancia a fallo de 2 brokers</td>
          </tr>
          <tr>
            <td><strong>Min In-Sync Replicas</strong></td>
            <td>2</td>
            <td>Garantiza durabilidad sin sacrificar performance</td>
          </tr>
        </tbody>
      </table>

      <h3>9.7.2 Topics Principales</h3>

      <table>
        <thead>
          <tr>
            <th>Topic</th>
            <th>Particiones</th>
            <th>Retención</th>
            <th>Uso</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>transactions.created</strong></td>
            <td>10</td>
            <td>30 días</td>
            <td>Nuevas transacciones bancarias</td>
          </tr>
          <tr>
            <td><strong>audit.events</strong></td>
            <td>5</td>
            <td>7 años</td>
            <td>Eventos de auditoría (compliance)</td>
          </tr>
          <tr>
            <td><strong>notifications.queue</strong></td>
            <td>5</td>
            <td>7 días</td>
            <td>Notificaciones pendientes de envío</td>
          </tr>
          <tr>
            <td><strong>data.sync</strong></td>
            <td>3</td>
            <td>1 día</td>
            <td>Sincronización CQRS entre bases de datos</td>
          </tr>
          <tr>
            <td><strong>saga.orchestration</strong></td>
            <td>5</td>
            <td>3 días</td>
            <td>Coordinación de transacciones distribuidas</td>
          </tr>
        </tbody>
      </table>

      <div class="justification">
        <div class="justification-title">Justificación de Kafka</div>
        <ul>
          <li><strong>Throughput:</strong> 1M+ mensajes/segundo por nodo</li>
          <li>
            <strong>Durabilidad:</strong> Réplicas + persistencia en disco
          </li>
          <li><strong>Escalabilidad:</strong> Particionamiento horizontal</li>
          <li><strong>Orden garantizado:</strong> Por partition key</li>
          <li>
            <strong>Replay capability:</strong> Re-procesar eventos históricos
          </li>
        </ul>
      </div>
    </div>

    <h2>9.8 Opciones de Cloud Provider</h2>

    <div class="section">
      <p>
        La arquitectura es agnóstica al proveedor cloud. Puede implementarse en
        cualquiera de las siguientes opciones:
      </p>

      <table>
        <thead>
          <tr>
            <th>Proveedor</th>
            <th>Servicio K8s</th>
            <th>Pros</th>
            <th>Cons</th>
            <th>Costo Estimado</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>AWS</strong></td>
            <td>EKS (Elastic Kubernetes Service)</td>
            <td>
              <ul>
                <li>Más maduro y estable</li>
                <li>Amplia documentación</li>
                <li>Integración con servicios AWS</li>
              </ul>
            </td>
            <td>
              <ul>
                <li>Curva de aprendizaje</li>
                <li>Costos pueden escalar</li>
              </ul>
            </td>
            <td>~$2,700/mes</td>
          </tr>
          <tr>
            <td><strong>Azure</strong></td>
            <td>AKS (Azure Kubernetes Service)</td>
            <td>
              <ul>
                <li>Control plane gratis</li>
                <li>Integración con Azure AD</li>
                <li>Buen soporte</li>
              </ul>
            </td>
            <td>
              <ul>
                <li>Menos maduro que EKS</li>
                <li>Documentación menor</li>
              </ul>
            </td>
            <td>~$2,400/mes</td>
          </tr>
          <tr>
            <td><strong>GCP</strong></td>
            <td>GKE (Google Kubernetes Engine)</td>
            <td>
              <ul>
                <li>Autopilot mode (managed)</li>
                <li>Integración nativa con Kubernetes</li>
                <li>Networking avanzado</li>
              </ul>
            </td>
            <td>
              <ul>
                <li>Menor adopción en LATAM</li>
                <li>Soporte limitado local</li>
              </ul>
            </td>
            <td>~$2,500/mes</td>
          </tr>
          <tr>
            <td><strong>OpenShift</strong></td>
            <td>OpenShift (Red Hat)</td>
            <td>
              <ul>
                <li>Kubernetes enterprise</li>
                <li>Seguridad robusta</li>
                <li>Soporte Red Hat</li>
              </ul>
            </td>
            <td>
              <ul>
                <li>Más costoso</li>
                <li>Más complejo</li>
              </ul>
            </td>
            <td>~$3,500/mes</td>
          </tr>
        </tbody>
      </table>

      <div class="success">
        <strong>Recomendación:</strong> AWS EKS por madurez, ecosistema y
        disponibilidad en LATAM. Alternativa viable: Azure AKS por
        costo/beneficio.
      </div>
    </div>

    <h2>9.9 Namespace Strategy</h2>

    <div class="section">
      <h3>9.9.1 Organización por Namespaces</h3>

      <div class="diagram">
        <div class="diagram-title">Estructura de Namespaces</div>
        <pre class="mermaid">
             flowchart TD
    classDef cluster fill:#e3f2fd,stroke:#1565c0,stroke-width:2px,stroke-dasharray:5 5,rx:10,ry:10
    classDef namespace fill:#fff3e0,stroke:#ef6c00,stroke-width:2px,rx:8,ry:8
    classDef production fill:#e8f5e8,stroke:#2e7d32,stroke-width:1.5px,rx:6,ry:6
    classDef preprod fill:#e3f2fd,stroke:#1565c0,stroke-width:1.5px,rx:6,ry:6
    classDef dev fill:#fce4ec,stroke:#c2185b,stroke-width:1.5px,rx:6,ry:6
    classDef qa fill:#fff8e1,stroke:#ff8f00,stroke-width:1.5px,rx:6,ry:6
    classDef monitoring fill:#e8eaf6,stroke:#283593,stroke-width:1.5px,rx:6,ry:6
    classDef system fill:#f5f5f5,stroke:#424242,stroke-width:1.5px,rx:6,ry:6

    KUBERNETES_CLUSTER[KUBERNETES CLUSTER]:::cluster

    subgraph KUBERNETES_CLUSTER
        NS1[Namespace: production]:::namespace
        NS2[Namespace: pre-production]:::namespace
        NS3[Namespace: development]:::namespace
        NS4[Namespace: qa]:::namespace
        NS5[Namespace: monitoring]:::namespace
        NS6[Namespace: kube-system]:::namespace
    end

    %% Contenido de cada namespace apilado verticalmente
    NS1 --> MSH1[MS-Históricos<br/>3 réplicas]:::production
    NS1 --> MSP1[MS-Pagos<br/>3 réplicas]:::production
    NS1 --> MSA1[MS-Autenticación<br/>3 réplicas]:::production
    NS1 --> MSAU1[MS-Auditoría<br/>2 réplicas]:::production
    NS1 --> APIG1[API-Gateway<br/>3 réplicas]:::production

    NS2 --> MSH2[MS-Históricos<br/>2 réplicas]:::preprod
    NS2 --> MSP2[MS-Pagos<br/>2 réplicas]:::preprod
    NS2 --> MSA2[MS-Autenticación<br/>2 réplicas]:::preprod
    NS2 --> APIG2[API-Gateway<br/>2 réplicas]:::preprod

    NS3 --> MSH3[MS-Históricos<br/>1 réplica]:::dev
    NS3 --> MSP3[MS-Pagos<br/>1 réplica]:::dev
    NS3 --> MSA3[MS-Autenticación<br/>1 réplica]:::dev

    NS4 --> MSH4[MS-Históricos<br/>1 réplica]:::qa
    NS4 --> MSP4[MS-Pagos<br/>1 réplica]:::qa

    NS5 --> PROM[Prometheus]:::monitoring
    NS5 --> GRAF[Grafana]:::monitoring
    NS5 --> ES[Elasticsearch]:::monitoring
    NS5 --> KIB[Kibana]:::monitoring

    NS6 --> DNS[kube-dns]:::system
    NS6 --> METRICS[metrics-server]:::system
    NS6 --> INGRESS[ingress-nginx]:::system

    %% Conexiones entre namespaces
    NS1 --> NS2
    NS2 --> NS3
    NS3 --> NS4
    NS4 --> NS5
    NS5 --> NS6
        </pre>
      </div>

      <h3>9.9.2 Beneficios de Namespaces</h3>

      <ul>
        <li>
          <strong>Aislamiento:</strong> Recursos de un ambiente no afectan otros
        </li>
        <li>
          <strong>RBAC Granular:</strong> Permisos específicos por namespace
        </li>
        <li>
          <strong>Resource Quotas:</strong> Límites de CPU/RAM por namespace
        </li>
        <li>
          <strong>Network Policies:</strong> Control de tráfico entre namespaces
        </li>
        <li>
          <strong>Organización:</strong> Separación lógica clara de ambientes
        </li>
      </ul>
    </div>

    <h2>9.10 Resource Quotas y Limits</h2>

    <div class="section">
      <h3>9.10.1 Resource Requests y Limits por Microservicio</h3>

      <table>
        <thead>
          <tr>
            <th>Microservicio</th>
            <th>CPU Request</th>
            <th>CPU Limit</th>
            <th>Memory Request</th>
            <th>Memory Limit</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>MS-Históricos</strong></td>
            <td>0.5 cores</td>
            <td>2 cores</td>
            <td>1 GB</td>
            <td>4 GB</td>
          </tr>
          <tr>
            <td><strong>MS-Pagos</strong></td>
            <td>1 core</td>
            <td>2 cores</td>
            <td>2 GB</td>
            <td>4 GB</td>
          </tr>
          <tr>
            <td><strong>MS-Autenticación</strong></td>
            <td>0.5 cores</td>
            <td>1.5 cores</td>
            <td>1 GB</td>
            <td>3 GB</td>
          </tr>
          <tr>
            <td><strong>MS-Notificaciones</strong></td>
            <td>0.5 cores</td>
            <td>2 cores</td>
            <td>1 GB</td>
            <td>3 GB</td>
          </tr>
          <tr>
            <td><strong>MS-Auditoría</strong></td>
            <td>0.5 cores</td>
            <td>1.5 cores</td>
            <td>1 GB</td>
            <td>3 GB</td>
          </tr>
          <tr>
            <td><strong>API-Gateway</strong></td>
            <td>1 core</td>
            <td>2 cores</td>
            <td>2 GB</td>
            <td>4 GB</td>
          </tr>
        </tbody>
      </table>

      <div class="note">
        <strong>Diferencia entre Request y Limit:</strong>
        <ul>
          <li>
            <strong>Request:</strong> Recursos garantizados que el pod siempre
            tendrá disponibles
          </li>
          <li>
            <strong>Limit:</strong> Máximo de recursos que el pod puede usar
            (burst capacity)
          </li>
        </ul>
      </div>

      <h3>9.10.2 Namespace Resource Quotas</h3>

      <table>
        <thead>
          <tr>
            <th>Namespace</th>
            <th>CPU Total</th>
            <th>Memory Total</th>
            <th>Pods Máximos</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>production</strong></td>
            <td>30 cores</td>
            <td>60 GB</td>
            <td>100</td>
          </tr>
          <tr>
            <td><strong>pre-production</strong></td>
            <td>15 cores</td>
            <td>30 GB</td>
            <td>50</td>
          </tr>
          <tr>
            <td><strong>development</strong></td>
            <td>8 cores</td>
            <td>16 GB</td>
            <td>30</td>
          </tr>
          <tr>
            <td><strong>qa</strong></td>
            <td>8 cores</td>
            <td>16 GB</td>
            <td>30</td>
          </tr>
        </tbody>
      </table>
    </div>

    <h2>9.11 Network Policies</h2>

    <div class="section">
      <h3>9.11.1 Segmentación de Red (Zero Trust)</h3>

      <p>
        Implementación de políticas de red para restringir comunicación entre
        pods:
      </p>

      <div class="diagram">
        <div class="diagram-title">Reglas de Network Policies</div>
        <pre class="mermaid">
flowchart TB
    Default["<b>Política por Defecto</b><br/>DENY ALL<br/>Solo comunicaciones explícitas"]
    
    subgraph Allowed["<b>Reglas Permitidas ✓</b>"]
        A1["Internet → API-Gateway<br/>(puerto 443)"]
        A2["API-Gateway → Microservicios"]
        A3["Microservicios → PostgreSQL<br/>(puerto 5432)"]
        A4["Microservicios → Redis<br/>(puerto 6379)"]
        A5["Microservicios → Kafka<br/>(puerto 9092)"]
        A6["Todos → Elasticsearch<br/>(puerto 9200)"]
        A7["Monitoring namespace → Todos<br/>(scraping)"]
    end
    
    subgraph Denied["<b>Reglas Denegadas ✗</b>"]
        D1["Microservicios NO pueden<br/>llamarse directamente<br/>(deben pasar por Gateway)"]
        D2["Internet NO puede acceder<br/>directamente a microservicios<br/>(solo vía Gateway)"]
        D3["Namespace development<br/>NO puede acceder a<br/>recursos de production"]
    end
    
    Default --> Allowed
    Default --> Denied
    
    style Default fill:#FFE5E5,stroke:#E74C3C,stroke-width:3px,rx:15,ry:15
    style Allowed fill:#E8F5E9,stroke:#4CAF50,stroke-width:3px,rx:15,ry:15
    style Denied fill:#FFEBEE,stroke:#C62828,stroke-width:3px,rx:15,ry:15
        </pre>
      </div>

      <h3>9.11.2 Beneficios de Network Policies</h3>

      <ul>
        <li>
          <strong>Seguridad en profundidad:</strong> Limita blast radius de un
          compromiso
        </li>
        <li>
          <strong>Compliance:</strong> Demuestra segmentación de red para
          auditorías
        </li>
        <li>
          <strong>Zero Trust:</strong> Ninguna comunicación es confiable por
          defecto
        </li>
        <li>
          <strong>Visibilidad:</strong> Políticas explícitas documentan
          arquitectura
        </li>
      </ul>
    </div>

    <h2>9.12 Ingress Controller</h2>

    <div class="section">
      <h3>9.12.1 NGINX Ingress Controller</h3>

      <div class="justification">
        <div class="justification-title">¿Por qué NGINX Ingress?</div>
        <ul>
          <li><strong>Madurez:</strong> Estable y ampliamente adoptado</li>
          <li><strong>Performance:</strong> Maneja 50K+ requests/segundo</li>
          <li>
            <strong>Features:</strong> SSL termination, rate limiting,
            redirects, rewrite rules
          </li>
          <li>
            <strong>Integración:</strong> Cert-manager para SSL automático con
            Let's Encrypt
          </li>
        </ul>
      </div>

      <h3>9.12.2 Configuración de SSL/TLS</h3>

      <table>
        <thead>
          <tr>
            <th>Aspecto</th>
            <th>Configuración</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Protocolo</strong></td>
            <td>TLS 1.3 (fallback a TLS 1.2)</td>
          </tr>
          <tr>
            <td><strong>Certificados</strong></td>
            <td>Let's Encrypt (renovación automática cada 60 días)</td>
          </tr>
          <tr>
            <td><strong>Cipher Suites</strong></td>
            <td>Solo strong ciphers (AES-256-GCM, ChaCha20)</td>
          </tr>
          <tr>
            <td><strong>HSTS</strong></td>
            <td>Enabled (max-age=31536000)</td>
          </tr>
          <tr>
            <td><strong>Certificate Pinning</strong></td>
            <td>Configurado en apps móviles</td>
          </tr>
        </tbody>
      </table>

      <h3>9.12.3 Rate Limiting en Ingress</h3>

      <table>
        <thead>
          <tr>
            <th>Endpoint</th>
            <th>Rate Limit</th>
            <th>Burst</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>/api/v1/login</strong></td>
            <td>5 req/min por IP</td>
            <td>10</td>
          </tr>
          <tr>
            <td><strong>/api/v1/register</strong></td>
            <td>3 req/hora por IP</td>
            <td>5</td>
          </tr>
          <tr>
            <td><strong>/graphql</strong></td>
            <td>100 req/min por usuario</td>
            <td>150</td>
          </tr>
          <tr>
            <td><strong>Global</strong></td>
            <td>1000 req/min por IP</td>
            <td>1500</td>
          </tr>
        </tbody>
      </table>
    </div>

    <h2>9.13 Persistent Storage</h2>

    <div class="section">
      <h3>9.13.1 Storage Classes</h3>

      <table>
        <thead>
          <tr>
            <th>Storage Class</th>
            <th>Tipo</th>
            <th>Performance</th>
            <th>Uso</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>ssd-fast</strong></td>
            <td>SSD (gp3 en AWS)</td>
            <td>Alta (3000 IOPS)</td>
            <td>Bases de datos transaccionales</td>
          </tr>
          <tr>
            <td><strong>ssd-standard</strong></td>
            <td>SSD (gp2 en AWS)</td>
            <td>Media (baseline IOPS)</td>
            <td>Redis, aplicaciones generales</td>
          </tr>
          <tr>
            <td><strong>hdd-bulk</strong></td>
            <td>HDD (st1 en AWS)</td>
            <td>Baja (throughput optimized)</td>
            <td>Logs, backups, archivos</td>
          </tr>
        </tbody>
      </table>

      <h3>9.13.2 Persistent Volume Claims</h3>

      <table>
        <thead>
          <tr>
            <th>Componente</th>
            <th>Storage Class</th>
            <th>Tamaño</th>
            <th>ReclaimPolicy</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>PostgreSQL Primary</strong></td>
            <td>ssd-fast</td>
            <td>500 GB</td>
            <td>Retain (manual deletion)</td>
          </tr>
          <tr>
            <td><strong>PostgreSQL Replicas</strong></td>
            <td>ssd-fast</td>
            <td>500 GB</td>
            <td>Retain</td>
          </tr>
          <tr>
            <td><strong>Redis</strong></td>
            <td>ssd-standard</td>
            <td>100 GB</td>
            <td>Delete</td>
          </tr>
          <tr>
            <td><strong>Kafka</strong></td>
            <td>ssd-standard</td>
            <td>1 TB</td>
            <td>Retain</td>
          </tr>
          <tr>
            <td><strong>Elasticsearch</strong></td>
            <td>ssd-standard</td>
            <td>2 TB</td>
            <td>Retain</td>
          </tr>
        </tbody>
      </table>
    </div>

    <h2>9.14 Secrets Management</h2>

    <div class="section">
      <h3>9.14.1 HashiCorp Vault Integration</h3>

      <p>Kubernetes se integra con Vault para inyección de secretos:</p>

      <div class="diagram">
        <div class="diagram-title">Flujo de Secrets Injection</div>
        <pre class="mermaid">
---
title: Flujo de Secretos con Vault en Kubernetes
---
flowchart TD
    classDef step fill:#e3f2fd,stroke:#1976d2,stroke-width:2px,rx:8,ry:8
    classDef vault fill:#fff3e0,stroke:#f57c00,stroke-width:2px,rx:8,ry:8
    classDef success fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px,rx:8,ry:8
    classDef optional fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px,rx:8,ry:8

    A[1. Pod inicia en Kubernetes]:::step
    B[2. Init Container ejecuta Vault Agent]:::vault
    C[3. Contenedor principal inicia]:::step
    D[4. Vault Agent Sidecar<br/>
        opcional]:::optional
    E[✅&nbsp;Aplicación&nbsp;ejecutándose<br/>
        con secretos seguros]:::success

    C1[Autentica con Vault usando<br/>
        Service Account]:::vault
    C2[Obtiene secretos<br/>
        DB passwords, API keys]:::vault
    C3[Escribe secretos en<br/>
        volumen compartido]:::vault
    D1[Lee secretos desde<br/>
        volumen NO desde<br/>
        variables de entorno]:::success
    D2[Renueva secretos<br/>
        automáticamente]:::optional
    D3[Refresca cada 1 hora]:::optional

    A --> B
    B --> C1
    B --> C2
    B --> C3
    C1 & C2 & C3 --> C
    C --> D1
    D1 --> D
    D --> D2
    D2 --> D3
    D3 --> E
        </pre>
      </div>

      <h3>9.14.2 Tipos de Secretos Gestionados</h3>

      <ul>
        <li>
          <strong>Database Credentials:</strong> PostgreSQL, Redis passwords
        </li>
        <li><strong>API Keys:</strong> Firebase, servicios externos</li>
        <li><strong>JWT Signing Keys:</strong> Para autenticación OAuth</li>
        <li><strong>Encryption Keys:</strong> Para datos sensibles</li>
        <li><strong>SSL Certificates:</strong> Para comunicación interna</li>
      </ul>

      <div class="warning">
        <strong>Nunca almacenar secretos en:</strong>
        <ul>
          <li>Variables de entorno en Kubernetes manifests</li>
          <li>ConfigMaps (son plain text)</li>
          <li>Git repositories</li>
          <li>Docker images</li>
        </ul>
      </div>
    </div>

    <h2>9.15 CI/CD Pipeline para Kubernetes</h2>

    <div class="section">
      <h3>9.15.1 Pipeline Automatizado</h3>

      <div class="diagram">
        <div class="diagram-title">Flujo CI/CD Completo</div>
        <pre class="mermaid">
---
title: Kubernetes CI/CD Pipeline
config:
  theme: base
  themeVariables:
    primaryColor: "#e3f2fd"
    primaryBorderColor: "#1976d2"
    primaryTextColor: "#0d47a1"
    clusterBkg: "#f5f5f5"
    clusterBorder: "#bdbdbd"
---
flowchart TD
    %% === INICIO DEL PIPELINE ===
    Start([Inicio del Pipeline]) --> Push
    
    subgraph Source["🔀 Fuente"]
        Push[Developer Push → Git<br/>GitHub/GitLab]
        MR[Merge Request Created]
        Push --> MR
    end
    
    Push --> CI
    MR --> CI
    
    CI[CI Pipeline Triggered] --> Tests
    
    %% === FASE DE TESTING ===
    subgraph Tests["🧪 Testing Phase"]
        direction TB
        Lint[Lint & Static Analysis] --> Unit
        Unit[Unit Tests] --> Integration
        Integration[Integration Tests] --> Security
        Security[Security Scan<br/>Snyk · Trivy · Checkmarx]
    end
    
    Tests --> Build
    
    %% === FASE DE CONSTRUCCIÓN ===
    subgraph Build["🏗️ Build & Package"]
        direction TB
        DockerBuild[Multi-stage Docker Build] --> Tagging
        Tagging[Tag Image<br/>git-sha · version · env] --> Scan
        Scan[Image Vulnerability Scan] --> PushRegistry
        PushRegistry[Push to Container Registry]
    end
    
    Build --> DeployDev
    
    %% === DESPLIEGUE EN DESARROLLO ===
    subgraph DeployDev["🟢 Development Environment"]
        direction TB
        ApplyDev[kubectl apply -f k8s/dev] --> WaitDev[Wait for Rollout]
        WaitDev --> SmokeTests[Smoke Tests]
        SmokeTests --> NotifyDev[Notify Team]
    end
    
    DeployDev --> Approval1{¿Tests pasan?}
    
    Approval1 -->|Sí| DeployStaging
    Approval1 -->|No| FailDev[❌ Fail Pipeline]
    
    %% === DESPLIEGUE EN STAGING ===
    subgraph DeployStaging["🟡 Pre-Production Environment"]
        direction TB
        ManualApproval1[Manual Approval Required] --> ApplyStaging
        ApplyStaging[kubectl apply -f k8s/staging] --> E2ETests
        E2ETests[End-to-End Tests] --> PerfTests[Performance Tests]
    end
    
    DeployStaging --> Approval2{¿QA Approved?}
    
    Approval2 -->|Sí| DeployProd
    Approval2 -->|No| FailStaging[❌ Rollback Staging]
    
    %% === DESPLIEGUE EN PRODUCCIÓN ===
    subgraph DeployProd["🔴 Production Deployment"]
        direction TB
        ManualApproval2[Change Advisory Board<br/>Approval Required] --> BlueGreen
        
        subgraph BlueGreen["🔄 Blue-Green Strategy"]
            direction TB
            DeployNew[Deploy to 'green' env] --> HealthChecks
            HealthChecks[Health Checks & Readiness<br/>5 min monitoring] --> TrafficSwitch
            TrafficSwitch[Switch Traffic<br/>Load Balancer Update] --> MonitorProd
        end
        
        MonitorProd[Monitor Production<br/>15 min observation window]
    end
    
    DeployProd --> HealthCheck{¿Error Rate > 1%?}
    
    HealthCheck -->|Sí| Rollback
    HealthCheck -->|No| Success
    
    %% === RESULTADOS FINALES ===
    subgraph Rollback["🔄 Rollback Automático"]
        direction TB
        TriggerRollback[Trigger Rollback] --> RevertTraffic
        RevertTraffic[Revert to 'blue' env] --> NotifyTeam
        NotifyTeam[Notify DevOps Team] --> Investigate[Investigate Issues]
    end
    
    subgraph Success["✅ Deployment Successful"]
        direction TB
        Cleanup[Cleanup Old Resources] --> NotifySuccess
        NotifySuccess[Notify Stakeholders] --> Metrics[Update Deployment Metrics]
    end
    
    %% === ESTILOS Y CLASES ===
    classDef source fill:#E3F2FD,stroke:#2196F3,stroke-width:3px,rx:10,ry:10
    classDef testing fill:#FFF9C4,stroke:#FBC02D,stroke-width:3px,rx:10,ry:10
    classDef build fill:#E8F5E9,stroke:#4CAF50,stroke-width:3px,rx:10,ry:10
    classDef dev fill:#E0F2F1,stroke:#00897B,stroke-width:3px,rx:10,ry:10
    classDef staging fill:#F3E5F5,stroke:#9C27B0,stroke-width:3px,rx:10,ry:10
    classDef prod fill:#FFE5E5,stroke:#E74C3C,stroke-width:3px,rx:10,ry:10
    classDef deployment fill:#E1F5FE,stroke:#0277BD,stroke-width:3px,rx:10,ry:10
    classDef rollback fill:#FFEBEE,stroke:#C62828,stroke-width:3px,rx:10,ry:10
    classDef success fill:#E8F5E9,stroke:#4CAF50,stroke-width:3px,rx:10,ry:10
    classDef decision fill:#FFFFFF,stroke:#666666,stroke-width:2px,rx:10,ry:10
    
    %% APLICAR ESTILOS ===
    class Source,Start,Push,MR source
    class Tests,Lint,Unit,Integration,Security testing
    class Build,DockerBuild,Tagging,Scan,PushRegistry build
    class DeployDev,ApplyDev,WaitDev,SmokeTests,NotifyDev dev
    class DeployStaging,ManualApproval1,ApplyStaging,E2ETests,PerfTests staging
    class DeployProd,ManualApproval2 prod
    class BlueGreen,DeployNew,HealthChecks,TrafficSwitch,MonitorProd deployment
    class Rollback,TriggerRollback,RevertTraffic,NotifyTeam,Investigate rollback
    class Success,Cleanup,NotifySuccess,Metrics success
    class Approval1,Approval2,HealthCheck decision
        </pre>
      </div>

      <h3>9.15.2 Deployment Strategies</h3>

      <table>
        <thead>
          <tr>
            <th>Estrategia</th>
            <th>Uso</th>
            <th>Pros</th>
            <th>Cons</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Rolling Update</strong></td>
            <td>Updates normales</td>
            <td class="pros">Zero downtime, gradual</td>
            <td>Dos versiones coexistiendo temporalmente</td>
          </tr>
          <tr>
            <td><strong>Blue-Green</strong></td>
            <td>Releases mayores</td>
            <td class="pros">Rollback instantáneo, testing completo</td>
            <td class="cons">Requiere 2x recursos temporalmente</td>
          </tr>
          <tr>
            <td><strong>Canary</strong></td>
            <td>Features de alto riesgo</td>
            <td class="pros">Exposición gradual (5% → 100%)</td>
            <td>Requiere feature flags</td>
          </tr>
        </tbody>
      </table>
    </div>

    <h2>9.16 Backup y Disaster Recovery</h2>

    <div class="section">
      <h3>9.16.1 Backup de Configuraciones</h3>

      <table>
        <thead>
          <tr>
            <th>Componente</th>
            <th>Método de Backup</th>
            <th>Frecuencia</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Kubernetes Manifests</strong></td>
            <td>Git repository (GitOps)</td>
            <td>Cada commit (versionado)</td>
          </tr>
          <tr>
            <td><strong>etcd (K8s state)</strong></td>
            <td>Velero snapshots</td>
            <td>Cada 6 horas</td>
          </tr>
          <tr>
            <td><strong>Persistent Volumes</strong></td>
            <td>Volume snapshots (cloud provider)</td>
            <td>Diario</td>
          </tr>
          <tr>
            <td><strong>Secrets (Vault)</strong></td>
            <td>Vault snapshots</td>
            <td>Diario</td>
          </tr>
        </tbody>
      </table>

      <h3>9.16.2 Plan de Disaster Recovery</h3>

      <table>
        <thead>
          <tr>
            <th>Escenario</th>
            <th>RTO</th>
            <th>RPO</th>
            <th>Procedimiento</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Pod crash</strong></td>
            <td>&lt; 30 segundos</td>
            <td>0</td>
            <td>K8s reinicia automáticamente</td>
          </tr>
          <tr>
            <td><strong>Node failure</strong></td>
            <td>&lt; 5 minutos</td>
            <td>0</td>
            <td>K8s reschedula pods en otros nodos</td>
          </tr>
          <tr>
            <td><strong>Zona AZ completa</strong></td>
            <td>&lt; 5 minutos</td>
            <td>0</td>
            <td>Réplicas en otras AZ asumen carga</td>
          </tr>
          <tr>
            <td><strong>Cluster completo</strong></td>
            <td>&lt; 2 horas</td>
            <td>&lt; 6 horas</td>
            <td>Restaurar desde Velero backup + DB restore</td>
          </tr>
          <tr>
            <td><strong>Región completa</strong></td>
            <td>&lt; 6 horas</td>
            <td>&lt; 1 día</td>
            <td>Failover a región secundaria (geo-replication)</td>
          </tr>
        </tbody>
      </table>
    </div>

    <h2>9.17 Estimación de Costos</h2>

    <div class="section">
      <h3>9.17.1 Costos Mensuales Estimados (AWS EKS)</h3>

      <table>
        <thead>
          <tr>
            <th>Componente</th>
            <th>Especificación</th>
            <th>Costo Mensual (USD)</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>EKS Control Plane</strong></td>
            <td>1 cluster</td>
            <td>$73</td>
          </tr>
          <tr>
            <td><strong>Nodos EC2 Producción</strong></td>
            <td>2x t3.xlarge (4vCPU, 16GB)</td>
            <td>$300</td>
          </tr>
          <tr>
            <td><strong>Nodos EC2 Pre-Prod</strong></td>
            <td>2x t3.large (2vCPU, 8GB)</td>
            <td>$150</td>
          </tr>
          <tr>
            <td><strong>Nodos EC2 Dev</strong></td>
            <td>1x t3.medium (2vCPU, 4GB)</td>
            <td>$40</td>
          </tr>
          <tr>
            <td><strong>Load Balancer</strong></td>
            <td>Application LB</td>
            <td>$25</td>
          </tr>
          <tr>
            <td><strong>EBS Volumes</strong></td>
            <td>5 TB SSD (gp3)</td>
            <td>$400</td>
          </tr>
          <tr>
            <td><strong>NAT Gateway</strong></td>
            <td>2 AZ</td>
            <td>$90</td>
          </tr>
          <tr>
            <td><strong>Data Transfer</strong></td>
            <td>1 TB egress</td>
            <td>$90</td>
          </tr>
          <tr>
            <td><strong>Backup Storage</strong></td>
            <td>1 TB S3 Glacier</td>
            <td>$15</td>
          </tr>
          <tr>
            <td><strong>CloudWatch Logs</strong></td>
            <td>50 GB/mes</td>
            <td>$30</td>
          </tr>
          <tr>
            <td><strong>Route 53</strong></td>
            <td>Hosted zone + queries</td>
            <td>$10</td>
          </tr>
        </tbody>
      </table>

      <div class="success">
        <strong>Total Estimado (solo K8s infra): ~$1,223/mes</strong><br />
        <strong
          >Total con bases de datos y servicios adicionales: ~$2,700/mes</strong
        >
      </div>

      <h3>9.17.2 Optimizaciones de Costo</h3>

      <ul>
        <li>
          <strong>Reserved Instances:</strong> 40-60% descuento comprando 1-3
          años → Ahorro $400/mes
        </li>
        <li>
          <strong>Spot Instances para Dev/QA:</strong> 70-90% descuento → Ahorro
          $80/mes
        </li>
        <li>
          <strong>S3 Lifecycle policies:</strong> Mover logs antiguos a Glacier
          → Ahorro $50/mes
        </li>
        <li>
          <strong>Right-sizing:</strong> Análisis mensual de uso → Ahorro 15-25%
        </li>
      </ul>

      <div class="success">
        <strong>Costo Optimizado: ~$2,000/mes (~$24,000/año)</strong>
      </div>
    </div>

    <div class="success">
      <h3>✅ Resumen del Capítulo</h3>
      <p>La infraestructura en Kubernetes propuesta ofrece:</p>
      <ul>
        <li>
          <strong>Multi-ambiente:</strong> Producción (2 nodos), Pre-prod (2
          nodos), Dev (1 nodo)
        </li>
        <li>
          <strong>Alta disponibilidad:</strong> Réplicas en múltiples AZ,
          anti-affinity rules
        </li>
        <li>
          <strong>Autoescalado:</strong> HPA + VPA para eficiencia de costos
          (40-60% ahorro)
        </li>
        <li>
          <strong>Seguridad:</strong> Network policies, secrets en Vault, RBAC
          granular
        </li>
        <li>
          <strong>Observabilidad:</strong> ELK Stack + Prometheus + Grafana
        </li>
        <li>
          <strong>CI/CD automatizado:</strong> Blue-green deployments, rollback
          automático
        </li>
        <li>
          <strong>Disaster Recovery:</strong> RTO &lt; 2 horas, backups
          automatizados
        </li>
        <li>
          <strong>Agnóstico al proveedor:</strong> Funciona en AWS, Azure, GCP u
          OpenShift
        </li>
        <li>
          <strong>Costo optimizado:</strong> ~$2,000/mes con optimizaciones vs
          $3,000+ sin ellas
        </li>
      </ul>
      <p>
        <strong>Recomendación:</strong> AWS EKS con Reserved Instances para
        producción y Spot Instances para dev/QA.
      </p>
    </div>

    <div class="footer">
      <p>Propuesta de Arquitectura - Sistema Bancario BP | Capítulo 9 de 17</p>
    </div>
    <script src="mermaid.min.js"></script>
    <script src="panzoom.min.js"></script>
    <script src="app.js"></script>
  </body>
</html>
