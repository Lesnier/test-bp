<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Capítulo 3 - Arquitectura de Microservicios</title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <div class="nav-header">
      <h2>Capítulo 3: Arquitectura de Microservicios</h2>
      <div class="nav-buttons">
        <a href="capitulo_02.html" class="nav-btn">← Anterior</a>
        <a href="index.html" class="nav-btn">Índice</a>
        <a href="capitulo_04.html" class="nav-btn">Siguiente →</a>
      </div>
    </div>

    <h1>3. ARQUITECTURA DE MICROSERVICIOS</h1>

    <h2>3.1 Catálogo de Microservicios</h2>

    <div class="section">
      <table>
        <thead>
          <tr>
            <th>Microservicio</th>
            <th>Responsabilidad</th>
            <th>Tecnología</th>
            <th>API</th>
            <th>Puerto</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>MS-Históricos</strong></td>
            <td>Consulta movimientos (CQRS Read)</td>
            <td>Node.js + GraphQL</td>
            <td>GraphQL</td>
            <td>3001</td>
          </tr>
          <tr>
            <td><strong>MS-Pagos-Internos</strong></td>
            <td>Transferencias mismo banco</td>
            <td>Node.js + GraphQL</td>
            <td>GraphQL</td>
            <td>3002</td>
          </tr>
          <tr>
            <td><strong>MS-Pagos-Interbancarios</strong></td>
            <td>Transferencias + SAGA</td>
            <td>Node.js + GraphQL</td>
            <td>GraphQL</td>
            <td>3003</td>
          </tr>
          <tr>
            <td><strong>MS-Datos-Cliente</strong></td>
            <td>Info básica cliente</td>
            <td>Node.js + GraphQL</td>
            <td>GraphQL</td>
            <td>3004</td>
          </tr>
          <tr>
            <td><strong>MS-Autenticación</strong></td>
            <td>OAuth 2.0 + Biometría</td>
            <td>Node.js + Passport.js</td>
            <td>REST</td>
            <td>3005</td>
          </tr>
          <tr>
            <td><strong>MS-Auditoría</strong></td>
            <td>Eventos + Worker Pool</td>
            <td>Node.js + GraphQL</td>
            <td>GraphQL</td>
            <td>3006</td>
          </tr>
          <tr>
            <td><strong>MS-Notificaciones</strong></td>
            <td>Email, SMS, Push + Workers</td>
            <td>Node.js + Bull Queue</td>
            <td>GraphQL</td>
            <td>3007</td>
          </tr>
          <tr>
            <td><strong>MS-Archivos</strong></td>
            <td>Upload/Download documentos</td>
            <td>Node.js + Multer</td>
            <td>REST</td>
            <td>3008</td>
          </tr>
          <tr>
            <td><strong>API-Gateway</strong></td>
            <td>Enrutamiento + Federation</td>
            <td>Apollo Gateway</td>
            <td>GraphQL</td>
            <td>8080</td>
          </tr>
        </tbody>
      </table>
    </div>

    <h2>3.2 Node.js con Worker Threads - Justificación Técnica</h2>

    <div class="section">
      <p>
        Node.js es la opción óptima para esta arquitectura por las siguientes
        razones:
      </p>

      <h3>3.2.1 Multithreading Real con Worker Threads</h3>

      <p>
        Node.js desde la versión 12+ incluye Worker Threads, permitiendo
        verdadero procesamiento paralelo en múltiples cores de CPU.
      </p>

      <div class="diagram">
        <div class="diagram-title">Arquitectura con Worker Threads</div>
        <pre class="mermaid">
graph TB
    MAIN[Main Thread - Event Loop
    •&nbsp;Recibe&nbsp;requests&nbsp;HTTP/GraphQL<br/>
    •&nbsp;Coordina&nbsp;workers&nbsp;no&nbsp;bloqueante<br/>
    •&nbsp;Gestiona&nbsp;I/O&nbsp;asíncrono&nbsp;DB,&nbsp;APIs<br/>
    •&nbsp;Responde&nbsp;a&nbsp;clientes]
    
    W1[Worker 1&nbsp;Agregaciones SQL]
    W2[Worker 2&nbsp;Reportes PDF Gen]
    W3[Worker 3&nbsp;OCR DocBiometría]
    W4[Worker 4&nbsp;ML Scoring]
    
    MAIN -->|Delega tareas<br/>CPU-intensive| W1
    MAIN -->|Delega tareas<br/>CPU-intensive| W2
    MAIN -->|Delega tareas<br/>CPU-intensive| W3
    MAIN -->|Delega tareas<br/>CPU-intensive| W4
    
    style MAIN fill:#667eea,stroke:#333,color:#fff,stroke-width:3px
    style W1 fill:#4caf50,stroke:#333,color:#fff
    style W2 fill:#4caf50,stroke:#333,color:#fff
    style W3 fill:#4caf50,stroke:#333,color:#fff
    style W4 fill:#4caf50,stroke:#333,color:#fff
        </pre>
      </div>

      <h3>3.2.2 Casos de Uso con Workers</h3>

      <ul>
        <li>
          <strong>Procesamiento de transacciones masivas:</strong> Validación
          paralela
        </li>
        <li>
          <strong>Generación de reportes:</strong> Agregaciones sin bloquear
          event loop
        </li>
        <li><strong>OCR de documentos:</strong> Tesseract.js en worker</li>
        <li><strong>Scoring de riesgo:</strong> Algoritmos ML en paralelo</li>
        <li>
          <strong>Procesamiento de eventos:</strong> Auditoría con
          enriquecimiento
        </li>
      </ul>

      <h3>3.2.3 Benchmark de Performance</h3>

      <table>
        <thead>
          <tr>
            <th>Operación</th>
            <th>Single-thread</th>
            <th>Con 4 Workers</th>
            <th>Mejora</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Requests para dashboard completo</td>
            <td>8-12</td>
            <td>1-2</td>
            <td class="pros">80-85%</td>
          </tr>
          <tr>
            <td>Bandwidth consumido (mobile)</td>
            <td>150 KB</td>
            <td>45 KB</td>
            <td class="pros">70%</td>
          </tr>
          <tr>
            <td>Latencia total (3G)</td>
            <td>3.2s</td>
            <td>1.1s</td>
            <td class="pros">66%</td>
          </tr>
          <tr>
            <td>Time-to-interactive</td>
            <td>4.5s</td>
            <td>1.8s</td>
            <td class="pros">60%</td>
          </tr>
          <tr>
            <td>Generar reporte 100K transacciones</td>
            <td>8.2s</td>
            <td>2.1s</td>
            <td class="pros">↑ 75%</td>
          </tr>
          <tr>
            <td>OCR de 10 documentos</td>
            <td>45s</td>
            <td>12s</td>
            <td class="pros">↑ 73%</td>
          </tr>
          <tr>
            <td>Scoring de 50 clientes</td>
            <td>15s</td>
            <td>4s</td>
            <td class="pros">↑ 73%</td>
          </tr>
          <tr>
            <td>Eventos procesados/segundo</td>
            <td>800</td>
            <td>3,200</td>
            <td class="pros">↑ 300%</td>
          </tr>
        </tbody>
      </table>

      <h2>3.3 GraphQL como Estándar de APIs (95%)</h2>

      <div class="section">
        <div class="note">
          <strong>Decisión Arquitectónica:</strong> GraphQL First - 95% GraphQL,
          5% REST
        </div>

        <h3>3.3.1 Justificación de GraphQL</h3>

        <h4>1. Eficiencia en Transferencia de Datos</h4>

        <div class="diagram">
          <div class="diagram-title">Comparación GraphQL vs REST</div>
          <pre>
        <strong>REST (requiere 3 requests):</strong>
        GET /customers/12345          → 2.3 KB
        GET /customers/12345/accounts → 5.1 KB  
        GET /accounts/xxx/transactions?limit=5 → 4.2 KB

        Total: 3 requests, 11.6 KB, ~1.8s en 3G

        <strong>GraphQL (1 request):</strong>
        query {
        customer(id: "12345") {
            name
            accounts {
            balance
            lastTransaction { amount date }
            }
        }
        }

        Total: 1 request, 4.1 KB, ~0.6s en 3G

        <strong>Resultado: 65% menos datos, 67% menos latencia</strong>
        </pre>
        </div>

        <h4>2. Beneficios Clave</h4>

        <ul>
          <li>
            <strong>Sin over-fetching:</strong> Cliente pide exactamente lo que
            necesita
          </li>
          <li>
            <strong>Sin under-fetching:</strong> Una query obtiene toda la info
            relacionada
          </li>
          <li>
            <strong>Evolución sin versionado:</strong> Agregar campos no rompe
            clientes
          </li>
          <li><strong>Type safety:</strong> Schema fuertemente tipado</li>
          <li><strong>Real-time:</strong> Subscriptions vía WebSocket</li>
          <li>
            <strong>Introspección:</strong> Autodocumentación con Playground
          </li>
        </ul>

        <h4>3. Performance Comparativa</h4>

        <table>
          <thead>
            <tr>
              <th>Métrica</th>
              <th>REST</th>
              <th>GraphQL</th>
              <th>Mejora</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Requests para dashboard completo</td>
              <td>8-12</td>
              <td>1-2</td>
              <td class="pros">80-85%</td>
            </tr>
            <tr>
              <td>Bandwidth consumido (mobile)</td>
              <td>150 KB</td>
              <td>45 KB</td>
              <td class="pros">70%</td>
            </tr>
            <tr>
              <td>Latencia total (3G)</td>
              <td>3.2s</td>
              <td>1.1s</td>
              <td class="pros">66%</td>
            </tr>
            <tr>
              <td>Time-to-interactive</td>
              <td>4.5s</td>
              <td>1.8s</td>
              <td class="pros">60%</td>
            </tr>
          </tbody>
        </table>

         <h4>4. Caché con GraphQL</h4>

      <p>Apollo Client implementa caché automático normalizado:</p>

      <div class="diagram">
        <div class="diagram-title">Normalized Cache en Cliente</div>
        <pre>
{
  "Customer:12345": {
    __typename: "Customer",
    id: "12345",
    name: "Juan Pérez",
    email: "juan@example.com"
  },
  "Account:acc-111": {
    __typename: "Account",
    id: "acc-111",
    balance: 50000,
    customer: { __ref: "Customer:12345" }
  }
}

<strong>Beneficio:</strong> Si Customer:12345 se actualiza en cualquier query,
todas las vistas que lo usen se actualizan automáticamente.
        </pre>
      </div>

      <ul>
        <li><strong>Invalidación selectiva:</strong> Evict field específico</li>
        <li>
          <strong>Refetch automático:</strong> Re-ejecutar queries cuando
          cambian datos
        </li>
        <li>
          <strong>Polling:</strong> Actualización cada X segundos si se requiere
        </li>
      </ul>
    </div>

      </div>

      <h3>3.3.2 Cuándo Usar REST (5%)</h3>

      <table>
        <thead>
          <tr>
            <th>Caso de Uso</th>
            <th>Endpoint REST</th>
            <th>Razón</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Upload archivos</td>
            <td>POST /api/v1/documents/upload</td>
            <td>GraphQL no eficiente para binarios</td>
          </tr>
          <tr>
            <td>Download archivos</td>
            <td>GET /api/v1/documents/:id/download</td>
            <td>Streaming optimizado</td>
          </tr>
          <tr>
            <td>Webhooks externos</td>
            <td>POST /webhooks/ach-callback</td>
            <td>Servicios externos esperan REST</td>
          </tr>
          <tr>
            <td>Health checks</td>
            <td>GET /health, GET /ready</td>
            <td>Simplicidad, usado por K8s</td>
          </tr>
        </tbody>
      </table>
    </div>

    <h2>3.4 Diagrama de Componentes con GraphQL</h2>

    <div class="diagram">
      <div class="diagram-title">Arquitectura Completa de Microservicios</div>
      <pre class="mermaid">
       graph TB
    GATEWAY[APOLLO GATEWAY&nbsp;GraphQL Federation<br/>
    •&nbsp;Schema Stitching]
    
    subgraph "CAPA&nbsp;DE&nbsp;SERVICIOS&nbsp;FRONTEND"
        MS1[MS-Históricos<br/>GraphQL<br/>
        •&nbsp;Subgraph
        •&nbsp;Query
        •&nbsp;Worker Pool]
        MS2[MS-Pagos<br/>GraphQL<br/>
        •&nbsp;Subgraph<br/>
        •&nbsp;Mutation<br/>
        •&nbsp;SAGA Pattern]
        MS3[MS-Autenticación<br/>REST<br/>
        •&nbsp;POST /login<br/>
        •&nbsp;OAuth 2.0]
    end
    
    KAFKA[KAFKA EVENT BUS<br/>
    •&nbsp;saga.orchestration<br/>
    •&nbsp;transactions.created<br/>
    •&nbsp;audit.events]
    
    subgraph "CAPA&nbsp;DE&nbsp;SERVICIOS&nbsp;BACKEND"
        MS4[MS-Auditoría<br/>GraphQL<br/>
        •&nbsp;Subscription]
        MS5[MS-Notificaciones<br/>GraphQL<br/>
        •&nbsp;Worker Pool]
        MS6[MS-Datos-Cliente<br/>GraphQL<br/>
        •&nbsp;DataLoader]
    end
    
    GATEWAY --> MS1
    GATEWAY --> MS2
    GATEWAY --> MS3
    
    MS1 --> KAFKA
    MS2 --> KAFKA
    MS3 --> KAFKA
    
    KAFKA --> MS4
    KAFKA --> MS5
    KAFKA --> MS6
    
    style GATEWAY fill:#667eea,stroke:#333,color:#fff,stroke-width:3px
    style KAFKA fill:#764ba2,stroke:#333,color:#fff,stroke-width:3px
    style MS1 fill:#4caf50,stroke:#333,color:#fff
    style MS2 fill:#4caf50,stroke:#333,color:#fff
    style MS3 fill:#ff9800,stroke:#333,color:#fff
    style MS4 fill:#2196F3,stroke:#333,color:#fff
    style MS5 fill:#2196F3,stroke:#333,color:#fff
    style MS6 fill:#2196F3,stroke:#333,color:#fff
    </pre
      >
    </div>

    <h2>3.5 PATRÓN SAGA PARA TRANSACCIONES DISTRIBUIDAS</h2>

    <div class="section">
      <h3>3.5.1 Problema que Resuelve SAGA</h3>

      <p>
        En arquitecturas de microservicios, las transacciones que abarcan
        múltiples servicios no pueden usar transacciones ACID tradicionales. El
        patrón SAGA soluciona esto dividiendo la transacción en pasos locales
        con <strong>acciones de compensación</strong>.
      </p>

      <div class="note">
        <strong>Escenario: Transferencia Interbancaria</strong><br /><br />
        Requiere coordinar:
        <ol>
          <li>Validar saldo (MS-Datos-Cliente)</li>
          <li>Debitar cuenta origen (MS-Pagos)</li>
          <li>Registrar auditoría (MS-Auditoría)</li>
          <li>Enviar a ACH Network (MS-Pagos-Interbancarios)</li>
          <li>Notificar usuario (MS-Notificaciones)</li>
        </ol>
        Si el paso 4 falla, necesitamos <strong>compensar</strong> los pasos 1,
        2 y 3.
      </div>

      <h3>3.5.2 SAGA con Orquestación y Redis</h3>

      <div class="diagram">
        <div class="diagram-title">Arquitectura SAGA</div>
        <pre class="mermaid">
        graph TB
          SAGA[SAGA&nbsp;ORCHESTRATOR<br/>
          MS-Pagos-Interbancarios<br/><br/>
          Estado en Redis TTL: 1h<br/>
          sagaId: saga-12345<br/>
          status: IN_PROGRESS<br/>
          steps:<br/> 
          &nbsp;&nbsp;validateBalance ✓<br/>
          &nbsp;&nbsp;debitAccount ✓<br/>
          &nbsp;&nbsp;sendToACH ✗ FAILED<br/>
          compensations:
          &nbsp;&nbsp;creditAccount,
          &nbsp;&nbsp;releaseHold]
    
          KAFKA1[KAFKATOPIC<br/>
          saga.orchestration]
          
          subgraph "EVENTOS PRINCIPALES"
              E1[debit.account]
              E2[audit.log]
              E3[send.to.ach]
          end
    
    FAIL[ACH FALLA ✗]
    
    KAFKA2[KAFKA TOPIC<br/>
    saga.compensation]
    
    subgraph "COMPENSACIONES"
        C1[credit.account<br/>Compensate]
        C2[delete.log<br/>Compensate]
        C3[notify.failure<br/>Compensate]
    end
    
    SAGA -->|Emit Events| KAFKA1
    KAFKA1 --> E1
    KAFKA1 --> E2
    KAFKA1 --> E3
    
    E3 --> FAIL
    
    E1 --> KAFKA2
    E2 --> KAFKA2
    FAIL --> KAFKA2
    
    KAFKA2 --> C1
    KAFKA2 --> C2
    KAFKA2 --> C3
    
    style SAGA fill:#667eea,stroke:#333,color:#fff,stroke-width:3px
    style KAFKA1 fill:#764ba2,stroke:#333,color:#fff
    style KAFKA2 fill:#764ba2,stroke:#333,color:#fff
    style E1 fill:#4caf50,stroke:#333,color:#fff
    style E2 fill:#4caf50,stroke:#333,color:#fff
    style E3 fill:#4caf50,stroke:#333,color:#fff
    style FAIL fill:#f44336,stroke:#333,color:#fff,stroke-width:3px
    style C1 fill:#ff9800,stroke:#333,color:#fff
    style C2 fill:#ff9800,stroke:#333,color:#fff
    style C3 fill:#ff9800,stroke:#333,color:#fff
        </pre>
      </div>

      <h3>3.5.3 Ventajas del Caché en Redis para SAGA</h3>

      <ol>
        <li><strong>Performance:</strong> Acceso ultrarrápido &lt;5ms</li>
        <li>
          <strong>TTL Automático:</strong> SAGAs antiguos se eliminan solos
        </li>
        <li>
          <strong>Atomicidad:</strong> Redis garantiza operaciones atómicas
        </li>
        <li>
          <strong>Distribución:</strong> Cualquier réplica puede continuar el
          SAGA
        </li>
        <li><strong>Debugging:</strong> Estado visible para troubleshooting</li>
      </ol>

      <h3>3.5.4 Acciones de Compensación</h3>

      <table>
        <thead>
          <tr>
            <th>Paso Original</th>
            <th>Acción de Compensación</th>
            <th>Tiempo Límite</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>validateBalance</td>
            <td>Liberar hold de saldo</td>
            <td>Inmediato</td>
          </tr>
          <tr>
            <td>debitAccount</td>
            <td>Acreditar monto debitado</td>
            <td>&lt; 30 segundos</td>
          </tr>
          <tr>
            <td>auditLog</td>
            <td>Marcar log como revertido</td>
            <td>&lt; 10 segundos</td>
          </tr>
          <tr>
            <td>sendToACH</td>
            <td>Solicitar cancelación ACH</td>
            <td>&lt; 5 minutos</td>
          </tr>
          <tr>
            <td>notifyUser</td>
            <td>Enviar notificación de fallo</td>
            <td>&lt; 1 minuto</td>
          </tr>
        </tbody>
      </table>

      <h3>3.5.5 Idempotencia en SAGA</h3>

      <div class="success">
        <strong>Todas las operaciones son idempotentes:</strong>
        <ul>
          <li>
            Si se intenta debitar dos veces, la segunda falla por idempotency
            key
          </li>
          <li>Si se intenta compensar dos veces, la segunda es no-op</li>
          <li>Kafka garantiza at-least-once delivery</li>
          <li>La idempotencia garantiza correctitud</li>
        </ul>
      </div>
    </div>

    <h2>3.6 Justificación Técnica Consolidada</h2>

    <div class="section">
      <div class="justification">
        <div class="justification-title">
          Resumen de Decisiones Arquitectónicas
        </div>

        <h3>Node.js con Worker Threads</h3>
        <ul>
          <li>Multithreading real: 300% mejora en procesamiento paralelo</li>
          <li>Escalabilidad vertical (workers) + horizontal (pods)</li>
          <li>Event loop no bloqueante para I/O intensivo</li>
          <li>Ecosistema maduro con 2M+ paquetes NPM</li>
          <li>Menor curva de aprendizaje (JavaScript full-stack)</li>
        </ul>

        <h3>GraphQL como Estándar (95%)</h3>
        <ul>
          <li>Reducción de latencia 60-70% vs REST</li>
          <li>Reducción de bandwidth 65-70%</li>
          <li>Sin versionado de APIs</li>
          <li>Type safety end-to-end</li>
          <li>Real-time con subscriptions</li>
          <li>Consultas flexibles sin nuevos endpoints</li>
        </ul>

        <h3>Patrón SAGA</h3>
        <ul>
          <li>Transacciones distribuidas sin 2PC</li>
          <li>Compensación automática de fallos</li>
          <li>Estado en Redis para performance</li>
          <li>Idempotencia garantizada</li>
          <li>Monitoreo completo de transacciones</li>
        </ul>
      </div>

      <h3>3.6.1 Comparativa: Arquitectura Propuesta vs Alternativas</h3>

      <table>
        <thead>
          <tr>
            <th>Aspecto</th>
            <th>Propuesta (Microservicios + GraphQL + Node.js)</th>
            <th>Monolito REST + Java</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Time-to-Market</strong></td>
            <td class="pros">4-6 meses</td>
            <td class="cons">8-12 meses</td>
          </tr>
          <tr>
            <td><strong>Latencia API</strong></td>
            <td class="pros">&lt;200ms (p95)</td>
            <td class="cons">350-500ms (p95)</td>
          </tr>
          <tr>
            <td><strong>Bandwidth mobile</strong></td>
            <td class="pros">45 KB/request</td>
            <td class="cons">150 KB/request</td>
          </tr>
          <tr>
            <td><strong>Escalabilidad</strong></td>
            <td class="pros">Independiente por servicio</td>
            <td class="cons">Todo o nada</td>
          </tr>
          <tr>
            <td><strong>Deployment</strong></td>
            <td class="pros">Sin downtime</td>
            <td class="cons">5-15 min downtime</td>
          </tr>
          <tr>
            <td><strong>Resiliencia</strong></td>
            <td class="pros">Fallo aislado</td>
            <td class="cons">Fallo total</td>
          </tr>
          <tr>
            <td><strong>Costo 3 años</strong></td>
            <td class="pros">$90,000</td>
            <td class="cons">$150,000+</td>
          </tr>
        </tbody>
      </table>

      <h3>3.6.2 ROI Estimado</h3>

      <div class="success">
        <strong>Retorno de Inversión:</strong>
        <ul>
          <li>
            <strong>Reducción 50% en time-to-market:</strong> $200,000 en
            revenue anticipado
          </li>
          <li>
            <strong>Reducción 70% en downtime:</strong> $50,000/año en pérdidas
            evitadas
          </li>
          <li>
            <strong>Mejora 30% en conversión:</strong> $500,000/año en revenue
            adicional
          </li>
          <li><strong>ROI Total:</strong> 600% en 3 años</li>
        </ul>
      </div>

     
    <div class="footer">
      <p>Propuesta de Arquitectura - Sistema Bancario BP | Capítulo 3 de 17</p>
    </div>

        <script src="mermaid.min.js"></script>
    <script src="panzoom.min.js"></script>
    <script src="app.js"></script>
  </body>
</html>
