<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cap√≠tulo 4 - Fuentes de Datos y Persistencia (CQRS)</title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <div class="nav-header">
      <h2>Cap√≠tulo 4: Fuentes de Datos y Persistencia (CQRS)</h2>
      <div class="nav-buttons">
        <a href="capitulo_03.html" class="nav-btn">‚Üê Anterior</a>
        <a href="index.html" class="nav-btn">√çndice</a>
        <a href="capitulo_05.html" class="nav-btn">Siguiente ‚Üí</a>
      </div>
    </div>

    <h1>4. FUENTES DE DATOS Y PERSISTENCIA (PATR√ìN CQRS)</h1>

    <h2>4.1 Estrategia de Bases de Datos</h2>

    <div class="section">
      <p>
        El sistema utiliza <strong>dos fuentes de datos principales</strong> con
        estrategia CQRS (Command Query Responsibility Segregation), separando
        las operaciones de lectura y escritura para optimizar el rendimiento.
      </p>

      <div class="note">
        <strong>Principio CQRS:</strong> Separar los modelos de lectura
        (queries) y escritura (commands) permite optimizar cada uno para su
        prop√≥sito espec√≠fico, mejorando significativamente el rendimiento del
        sistema.
      </div>

      <h3>4.1.1 Base de Datos Core (Escritura)</h3>
      <ul>
        <li>
          <strong>Prop√≥sito:</strong> Operaciones transaccionales (CREATE,
          UPDATE, DELETE)
        </li>
        <li><strong>Tecnolog√≠a:</strong> PostgreSQL 15+</li>
        <li>
          <strong>Contenido:</strong> Movimientos financieros, productos,
          transacciones
        </li>
        <li>
          <strong>Caracter√≠sticas:</strong> ACID completo, integridad
          referencial, transacciones complejas
        </li>
      </ul>

      <h3>4.1.2 Base de Datos de Lectura (Read Model)</h3>
      <ul>
        <li><strong>Prop√≥sito:</strong> Consultas optimizadas (SELECT)</li>
        <li><strong>Tecnolog√≠a:</strong> MongoDB 7.0+ (NoSQL denormalizada)</li>
        <li>
          <strong>Contenido:</strong> Vistas materializadas, hist√≥ricos
          denormalizados
        </li>
        <li>
          <strong>Caracter√≠sticas:</strong> Sin joins, queries ultra-r√°pidas,
          agregaciones eficientes
        </li>
      </ul>

      <h3>4.1.3 Base de Datos de Detalles de Cliente</h3>
      <ul>
        <li>
          <strong>Prop√≥sito:</strong> Informaci√≥n complementaria del cliente
        </li>
        <li><strong>Tecnolog√≠a:</strong> PostgreSQL 15+</li>
        <li>
          <strong>Contenido:</strong> Datos personales, preferencias,
          configuraciones
        </li>
      </ul>

      <h3>4.1.4 Base de Datos de Auditor√≠a</h3>
      <ul>
        <li><strong>Prop√≥sito:</strong> Compliance, logs, trazabilidad</li>
        <li><strong>Tecnolog√≠a:</strong> Elasticsearch 8.11+</li>
        <li>
          <strong>Contenido:</strong> Todos los eventos del sistema, b√∫squeda
          full-text
        </li>
      </ul>
    </div>

    <h2>4.2 Diagrama de Arquitectura CQRS</h2>

    <div class="diagram">
      <div class="diagram-title">Separaci√≥n de Lecturas y Escrituras</div>
      <pre class="mermaid">
flowchart TD
    %% Estilos globales
    classDef capa fill:#cfe8fc,stroke:#4682b4,stroke-width:2px,color:#000,border-radius:10px;
    classDef dbwrite fill:#d5f5e3,stroke:#2e8b57,stroke-width:2px,color:#000,border-radius:10px;
    classDef dbread fill:#fce5cd,stroke:#d2691e,stroke-width:2px,color:#000,border-radius:10px;
    classDef kafka fill:#f6d8f8,stroke:#8b008b,stroke-width:2px,color:#000,border-radius:10px;
    classDef detalle fill:#ffffff,stroke:#888,stroke-width:1.5px,color:#000,border-radius:8px;

    %% Nodos principales
    A["CAPA DE APLICACION<br/>
        Microservicios GraphQL"]
    A -->|WRITE - Mutations| B["PostgreSQL WRITE DB<br/>
                                Transaccional"]
    A -->|READ - Queries| C["MongoDB READ DB<br/>
                             Optimizada"]

    %% Detalles PostgreSQL
    B --> B1["Movimientos"]
    B --> B2["Productos"]
    B --> B3["Transacciones"]
    B --> B4["ACID completo"]

    %% Detalles MongoDB
    C --> C1["Vista Hist√≥rico"]
    C --> C2["Agregaciones"]
    C --> C3["B√∫squedas"]
    C --> C4["Denormalizado / Sin Joins"]

    %% Kafka Event Bus
    B -->|Event Emitted| D["KAFKA EVENT BUS<br/>
                            Topic: data.sync<br/>
                            Latencia: 100‚Äì500 ms"]
    D -->|Sync&nbsp;-&nbsp;Consistencia&nbsp;Eventual| C

    %% Asignar estilos
    class A capa;
    class B dbwrite;
    class C dbread;
    class D kafka;
    class B1,B2,B3,B4,C1,C2,C3,C4 detalle;

    </pre>
    </div>

    <h2>4.3 Consistencia Eventual</h2>

    <div class="section">
      <div class="justification">
        <div class="justification-title">
          Justificaci√≥n de Consistencia Eventual
        </div>

        <p>La consistencia eventual es apropiada para este sistema porque:</p>

        <ul>
          <li>
            <strong>Mayor disponibilidad del sistema</strong> (Teorema CAP:
            elegimos AP sobre C)
          </li>
          <li>
            <strong>Escalabilidad horizontal sin bloqueos</strong> entre
            servicios
          </li>
          <li>
            <strong>Mejor performance en lecturas</strong> (sin joins complejos)
          </li>
          <li>
            <strong>Resiliencia ante fallos de red</strong> entre servicios
          </li>
          <li>
            <strong>Reducci√≥n de contenci√≥n</strong> en la base de datos de
            escritura
          </li>
        </ul>
      </div>

      <h3>4.3.1 Implementaci√≥n de la Sincronizaci√≥n</h3>

      <ol>
        <li>
          <strong>Escritura en PostgreSQL:</strong> Las escrituras se realizan
          primero en PostgreSQL con garant√≠as ACID completas
        </li>
        <li>
          <strong>Emisi√≥n de evento:</strong> Se emite un evento a Kafka tras
          cada escritura exitosa
        </li>
        <li>
          <strong>Consumidor escucha:</strong> Un consumidor dedicado escucha el
          topic data.sync
        </li>
        <li>
          <strong>Actualizaci√≥n de lectura:</strong> El consumidor actualiza la
          base de lectura (MongoDB)
        </li>
        <li><strong>Latencia t√≠pica:</strong> 100-500ms de sincronizaci√≥n</li>
      </ol>

      <h3>4.3.2 Casos de Uso Apropiados</h3>

      <table>
        <thead>
          <tr>
            <th>Tipo de Consulta</th>
            <th>Base de Datos</th>
            <th>Justificaci√≥n</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Hist√≥rico de movimientos</td>
            <td>MongoDB (Read)</td>
            <td>Consistencia eventual aceptable (delay de segundos OK)</td>
          </tr>
          <tr>
            <td>Dashboards y reportes</td>
            <td>MongoDB (Read)</td>
            <td>Datos agregados, no requieren tiempo real</td>
          </tr>
          <tr>
            <td>Saldo actual de cuenta</td>
            <td>PostgreSQL (Write)</td>
            <td>Requiere consistencia fuerte, lectura directa</td>
          </tr>
          <tr>
            <td>Validaci√≥n de transferencia</td>
            <td>PostgreSQL (Write)</td>
            <td>Operaci√≥n cr√≠tica, requiere ACID</td>
          </tr>
          <tr>
            <td>B√∫squeda de transacciones</td>
            <td>MongoDB (Read)</td>
            <td>Optimizada para b√∫squedas complejas</td>
          </tr>
        </tbody>
      </table>

      <div class="success">
        <strong>Resultado:</strong> 70% de las consultas van a MongoDB (r√°pidas,
        sin carga en PostgreSQL), 30% a PostgreSQL (operaciones cr√≠ticas con
        consistencia fuerte).
      </div>
    </div>

    <h2>4.4 Flujo de Sincronizaci√≥n Detallado</h2>

    <div class="section">
      <div class="diagram">
        <div class="diagram-title">Flujo Completo de Sincronizaci√≥n CQRS</div>
        <pre class="mermaid">
flowchart TD
    %% Estilos
    classDef paso fill:#d6eaf8,stroke:#2471a3,stroke-width:2px,color:#000,border-radius:10px;
    classDef dbwrite fill:#d5f5e3,stroke:#239b56,stroke-width:2px,color:#000,border-radius:10px;
    classDef kafka fill:#f6d8f8,stroke:#8b008b,stroke-width:2px,color:#000,border-radius:10px;
    classDef worker fill:#fdebd0,stroke:#d68910,stroke-width:2px,color:#000,border-radius:10px;
    classDef dbread fill:#fcf3cf,stroke:#b7950b,stroke-width:2px,color:#000,border-radius:10px;
    classDef resultado fill:#e8daef,stroke:#6c3483,stroke-width:2px,color:#000,border-radius:10px;

    %% PASO 1
    A["üü¢ PASO 1:<br/>Usuario realiza transferencia"]
    A --> B["GraphQL Mutation ‚Üí Microservicio de Pagos"]

    %% PASO 2
    B --> C["PASO 2:<br/>Escritura en PostgreSQL (Write DB)"]
    C --> C1["BEGIN TRANSACTION"]
    C --> C2["INSERT INTO transactions(...)"]
    C --> C3["UPDATE accounts SET balance = balance - amount"]
    C --> C4["COMMIT TRANSACTION ‚úì"]
    C --> C5["Transacci√≥n exitosa<br/>(ACID garantizado)"]

    %% PASO 3
    C --> D["PASO 3:<br/>Emisi√≥n de Evento a Kafka"]
    D --> D1["Event:<br/>{ type: 'TRANSACTION_CREATED',<br/>transactionId: 'txn-12345',<br/>accountId: 'acc-67890',<br/>amount: 1000,<br/>timestamp: '2025-10-06T10:30:00Z' }"]
    D --> D2["Publicado en topic: data.sync"]

    %% PASO 4
    D --> E["PASO 4:<br/>Consumidor procesa evento"]
    E --> E1["Worker Thread procesa en paralelo"]
    E --> E2["Enriquece datos:<br/>+ info cliente, + categor√≠a"]
    E --> E3["Latencia: 100‚Äì300 ms"]

    %% PASO 5
    E --> F["PASO 5:<br/>Actualizaci√≥n en MongoDB (Read DB)"]
    F --> F1["db.transactions.insertOne({<br/>transactionId:'txn-12345',<br/>accountId:'acc-67890',<br/>amount:1000,<br/>customerName:'Juan P√©rez',<br/>category:'Transferencia',<br/>timestamp:'2025-10-06T10:30:00Z'<br/>})"]
    F --> F2["Actualizaci√≥n denormalizada<br/>(sin joins)"]

    %% PASO 6
    F --> G["PASO 6:<br/>Dato disponible para consultas r√°pidas"]
    G --> G1["Consultas desde MongoDB: < 20ms<br/>(vs 150‚Äì200ms si fuera join en PostgreSQL)"]

    %% Asignaci√≥n de clases
    class A,B paso;
    class C,C1,C2,C3,C4,C5 dbwrite;
    class D,D1,D2 kafka;
    class E,E1,E2,E3 worker;
    class F,F1,F2 dbread;
    class G,G1 resultado;

        </pre>
      </div>
    </div>

    <h2>4.5 Persistencia para Clientes Frecuentes - Cach√© con Redis</h2>

    <div class="section">
      <p>
        Para optimizar a√∫n m√°s el rendimiento, se implementa una capa de cach√©
        con Redis para datos de clientes frecuentes.
      </p>

      <div class="diagram">
        <div class="diagram-title">Estrategia de Cach√© Multi-Nivel</div>
        <pre class="mermaid">
flowchart TD
    %% ==== Estilos ====
    classDef ms fill:#d6eaf8,stroke:#2471a3,stroke-width:2px,color:#000,border-radius:10px;
    classDef cache fill:#fdebd0,stroke:#d68910,stroke-width:2px,color:#000,border-radius:10px;
    classDef db fill:#d5f5e3,stroke:#1e8449,stroke-width:2px,color:#000,border-radius:10px;

    %% ==== Microservicio ====
    A["MS-Datos-Cliente"]
    class A ms

    %% ==== Conexiones ====
    A --> B["Redis<br/>(Cache)<br/><br/>TTL: 1 hora<br/>LRU eviction<br/>Hit rate: 70%"]
    A --> C["PostgreSQL<br/>(Fuente)<br/><br/>Datos Cliente<br/>Authoritative"]

    %% ==== Clases ====
    class B cache
    class C db
        </pre>
      </div>

      <div class="note">
        <strong> Flujo de Lectura: </strong>
        <ul>
          <li>1. Request ‚Üí Redis (cach√©)</li>
          <li>2. Cache HIT (70%) ‚Üí Respuesta inmediata (2ms)</li>
          <li>3. Cache MISS (30%) ‚Üí PostgreSQL (50ms) + Guardar en Redis</li>
        </ul>
      </div>

      <h3>4.5.1 Estrategia de Cach√©</h3>

      <ul>
        <li>
          <strong>Datos cacheados:</strong> Informaci√≥n de clientes frecuentes
          (regla 80/20: Top 20% genera 80% del tr√°fico)
        </li>
        <li>
          <strong>TTL (Time To Live):</strong> 1 hora para balance entre
          frescura y performance
        </li>
        <li>
          <strong>Pol√≠tica de evicci√≥n:</strong> LRU (Least Recently Used)
        </li>
        <li>
          <strong>Invalidaci√≥n proactiva:</strong> Cuando se actualiza el
          cliente, se invalida el cach√©
        </li>
        <li><strong>Hit rate objetivo:</strong> >70%</li>
      </ul>

      <h3>4.5.2 Beneficios Medibles</h3>

      <table>
        <thead>
          <tr>
            <th>M√©trica</th>
            <th>Sin Cach√©</th>
            <th>Con Redis</th>
            <th>Mejora</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Latencia promedio</td>
            <td>50ms</td>
            <td>15ms (70% hits a 2ms)</td>
            <td class="pros">70%</td>
          </tr>
          <tr>
            <td>Queries a PostgreSQL</td>
            <td>10,000/min</td>
            <td>3,000/min</td>
            <td class="pros">70%</td>
          </tr>
          <tr>
            <td>Carga CPU PostgreSQL</td>
            <td>60%</td>
            <td>20%</td>
            <td class="pros">67%</td>
          </tr>
          <tr>
            <td>Throughput (req/seg)</td>
            <td>500</td>
            <td>1,500</td>
            <td class="pros">200%</td>
          </tr>
        </tbody>
      </table>
    </div>

    <h2>4.6 Modelo de Datos</h2>

    <div class="section">
      <h3>4.6.1 Esquema PostgreSQL (Write DB)</h3>

      <pre>
-- Tabla de Cuentas
CREATE TABLE accounts (
    id UUID PRIMARY KEY,
    customer_id UUID NOT NULL,
    account_number VARCHAR(20) UNIQUE NOT NULL,
    balance DECIMAL(15,2) NOT NULL DEFAULT 0,
    account_type VARCHAR(20) NOT NULL,
    status VARCHAR(20) NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

-- Tabla de Transacciones (Write Model)
CREATE TABLE transactions (
    id UUID PRIMARY KEY,
    account_id UUID NOT NULL REFERENCES accounts(id),
    transaction_type VARCHAR(50) NOT NULL,
    amount DECIMAL(15,2) NOT NULL,
    balance_after DECIMAL(15,2) NOT NULL,
    description TEXT,
    status VARCHAR(20) NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    idempotency_key VARCHAR(100) UNIQUE
);

-- √çndices optimizados para escritura
CREATE INDEX idx_transactions_account ON transactions(account_id);
CREATE INDEX idx_transactions_created ON transactions(created_at DESC);
    </pre
      >

      <h3>4.6.2 Esquema MongoDB (Read DB)</h3>

      <pre>
// Colecci√≥n de Transacciones (Read Model - Denormalizado)
{
  "_id": "txn-12345",
  "transactionId": "txn-12345",
  "accountId": "acc-67890",
  "accountNumber": "1234567890",
  
  // Datos denormalizados del cliente
  "customer": {
    "id": "cust-111",
    "name": "Juan P√©rez",
    "email": "juan@example.com"
  },
  
  // Datos de la transacci√≥n
  "type": "TRANSFER_OUT",
  "amount": 1000.00,
  "balanceAfter": 48000.00,
  "description": "Transferencia a cuenta externa",
  "category": "Transferencia",
  "status": "COMPLETED",
  
  // Metadata enriquecida
  "timestamp": ISODate("2025-10-06T10:30:00Z"),
  "tags": ["transfer", "external", "high-amount"],
  
  // √çndices para b√∫squedas r√°pidas
  "searchableText": "transferencia juan perez 1000"
}

// √çndices optimizados para lectura
db.transactions.createIndex({ "accountId": 1, "timestamp": -1 })
db.transactions.createIndex({ "customer.id": 1 })
db.transactions.createIndex({ "searchableText": "text" })
    </pre
      >
    </div>

    <h2>4.7 Gesti√≥n de R√©plicas y Alta Disponibilidad</h2>

    <div class="section">
      <h3>4.7.1 PostgreSQL - Configuraci√≥n Master-Replica</h3>

      <div class="diagram">
        <div class="diagram-title">Arquitectura de Replicaci√≥n PostgreSQL</div>
        <pre class="mermaid">
flowchart TD
    A["Primary<br>(Read+Write)"] -- Streaming Replication<br>(As√≠ncrona) --> R1["Replica 1<br>(Read-only)<br>Zona AZ-A"]
    A --> R2["Replica 2<br>(Read-only)<br>Zona AZ-B"] & R3["Replica 3<br>(Read-only)<br>Zona AZ-C"]

    A@{ shape: rounded}
    R1@{ shape: rounded}
    R2@{ shape: rounded}
    R3@{ shape: rounded}
     A:::pastel
     A:::Peach
     A:::Pine
     R1:::pastel
     R1:::Ash
     R1:::Peach
     R2:::pastel
     R2:::Peach
     R3:::pastel
     R3:::Peach
    classDef pastel fill:#ffe7ba,stroke:#a88039,stroke-width:2px,color:#463918
    classDef Pine stroke-width:1px, stroke-dasharray:none, stroke:#254336, fill:#27654A, color:#FFFFFF
    classDef Ash stroke-width:1px, stroke-dasharray:none, stroke:#999999, fill:#EEEEEE, color:#000000
    classDef Peach stroke-width:1px, stroke-dasharray:none, stroke:#FBB35A, fill:#FFEFDB, color:#8F632D



        </pre>
      </div>

      <ul>
        <li>
          <strong>Replicaci√≥n as√≠ncrona:</strong> Balance entre performance y
          durabilidad
        </li>
        <li>
          <strong>Failover autom√°tico:</strong> Patroni o Stolon para promoci√≥n
          autom√°tica
        </li>
        <li>
          <strong>Backup autom√°tico:</strong> Diario + PITR (Point-in-Time
          Recovery)
        </li>
        <li>
          <strong>Multi-AZ:</strong> R√©plicas en diferentes zonas de
          disponibilidad
        </li>
      </ul>

      <h3>4.7.2 MongoDB - Replica Set</h3>

      <ul>
        <li>
          <strong>Replica Set de 3 nodos:</strong> 1 Primary + 2 Secondary
        </li>
        <li>
          <strong>Read Preference:</strong> Configurado para leer de secundarios
          (reduce carga en primary)
        </li>
        <li>
          <strong>Write Concern:</strong> majority (espera confirmaci√≥n de
          mayor√≠a)
        </li>
        <li>
          <strong>Elecci√≥n autom√°tica:</strong> Si primary cae, se elige nuevo
          primary autom√°ticamente
        </li>
      </ul>
    </div>

    <h2>4.8 Estrategia de Backup y Recuperaci√≥n</h2>

    <div class="section">
      <table>
        <thead>
          <tr>
            <th>Tipo de Backup</th>
            <th>Frecuencia</th>
            <th>Retenci√≥n</th>
            <th>RTO</th>
            <th>RPO</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Full Backup PostgreSQL</strong></td>
            <td>Semanal (Domingo 2am)</td>
            <td>3 meses</td>
            <td>30 min</td>
            <td>7 d√≠as</td>
          </tr>
          <tr>
            <td><strong>Incremental PostgreSQL</strong></td>
            <td>Diario (2am)</td>
            <td>30 d√≠as</td>
            <td>20 min</td>
            <td>1 d√≠a</td>
          </tr>
          <tr>
            <td><strong>WAL Logs PostgreSQL</strong></td>
            <td>Continuo</td>
            <td>7 d√≠as</td>
            <td>15 min</td>
            <td>5 min</td>
          </tr>
          <tr>
            <td><strong>MongoDB Snapshot</strong></td>
            <td>Cada 6 horas</td>
            <td>48 horas</td>
            <td>10 min</td>
            <td>6 horas</td>
          </tr>
          <tr>
            <td><strong>Redis Persistence (RDB)</strong></td>
            <td>Cada hora</td>
            <td>24 horas</td>
            <td>5 min</td>
            <td>1 hora</td>
          </tr>
        </tbody>
      </table>

      <div class="note">
        <strong>RTO (Recovery Time Objective):</strong> Tiempo m√°ximo aceptable
        para recuperar el servicio.<br />
        <strong>RPO (Recovery Point Objective):</strong> Cantidad m√°xima
        aceptable de datos que se pueden perder.
      </div>
    </div>

    <h2>4.9 Ventajas del Patr√≥n CQRS Implementado</h2>

    <div class="section">
      <div class="success">
        <h3>‚úì Beneficios Comprobados</h3>
        <ol>
          <li>
            <strong>Performance de Lectura:</strong> Queries 5-10x m√°s r√°pidas
            (sin joins, datos denormalizados)
          </li>
          <li>
            <strong>Escalabilidad Independiente:</strong> Escalar lectura y
            escritura por separado seg√∫n necesidad
          </li>
          <li>
            <strong>Optimizaci√≥n Espec√≠fica:</strong> PostgreSQL para
            transacciones ACID, MongoDB para consultas complejas
          </li>
          <li>
            <strong>Menor Contenci√≥n:</strong> Lecturas no bloquean escrituras
          </li>
          <li>
            <strong>Flexibilidad de Schema:</strong> Read model puede tener
            m√∫ltiples vistas sin afectar write model
          </li>
          <li>
            <strong>Reducci√≥n de Carga:</strong> 70% de queries van a MongoDB,
            liberando PostgreSQL para transacciones
          </li>
        </ol>
      </div>

      <div class="warning">
        <h3>‚ö†Ô∏è Consideraciones Importantes</h3>
        <ul>
          <li>
            <strong>Complejidad:</strong> Mayor complejidad operacional (2 bases
            de datos a mantener)
          </li>
          <li>
            <strong>Consistencia Eventual:</strong> Los clientes deben entender
            delays de 100-500ms
          </li>
          <li>
            <strong>Sincronizaci√≥n:</strong> Kafka debe estar siempre disponible
          </li>
          <li>
            <strong>Debugging:</strong> M√°s dif√≠cil debuggear problemas de
            sincronizaci√≥n
          </li>
        </ul>
      </div>
    </div>

    <div class="footer">
      <p>Propuesta de Arquitectura - Sistema Bancario BP | Cap√≠tulo 4 de 17</p>
    </div>
    <script src="mermaid.min.js"></script>
    <script src="panzoom.min.js"></script>
    <script src="app.js"></script>
  </body>
</html>
