<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Capítulo 2 - Arquitectura General del Sistema</title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <div class="nav-header">
      <h2>Capítulo 2: Arquitectura General del Sistema</h2>
      <div class="nav-buttons">
        <a href="capitulo_01.html" class="nav-btn">← Anterior</a>
        <a href="index.html" class="nav-btn">Índice</a>
        <a href="capitulo_03.html" class="nav-btn">Siguiente →</a>
      </div>
    </div>

    <h1>2. ARQUITECTURA GENERAL DEL SISTEMA</h1>

    <h2>2.1 Vista de Contexto</h2>

    <div class="section">
      <p>
        El sistema bancario BP permite a los usuarios gestionar sus finanzas
        mediante aplicaciones web (SPA) y móvil, con las siguientes capacidades
        principales:
      </p>

      <ul>
        <li>
          <strong>Consulta de histórico de movimientos:</strong> Acceso a
          transacciones pasadas con filtros avanzados
        </li>
        <li>
          <strong>Transferencias intrabancarias:</strong> Pagos entre cuentas
          del mismo banco
        </li>
        <li>
          <strong>Transferencias interbancarias:</strong> Pagos a otros bancos
          con patrón SAGA
        </li>
        <li>
          <strong>Consulta de datos básicos:</strong> Información del cliente y
          productos
        </li>
        <li>
          <strong>Notificaciones en tiempo real:</strong> Vía GraphQL
          Subscriptions y Push/SMS
        </li>
        <li>
          <strong>Autenticación biométrica:</strong> Face ID, Touch ID y métodos
          tradicionales
        </li>
      </ul>
    </div>

    <h2>2.2 Diagrama de Contexto</h2>

    <div class="diagram">
      <div class="diagram-title">Arquitectura de Alto Nivel</div>
      <pre>
┌──────────────────────────────────────────────────────────────┐
│                       USUARIOS FINALES                        │
│                                                               │
│    ┌─────────────┐              ┌──────────────┐            │
│    │   SPA Web   │              │  App Móvil   │            │
│    │  (ReactJS)  │              │ (React Native)│            │
│    └──────┬──────┘              └───────┬──────┘            │
└───────────┼─────────────────────────────┼───────────────────┘
            │                             │
            └──────────────┬──────────────┘
                           │ HTTPS/TLS 1.3
            ┌──────────────▼──────────────┐
            │     WAF (Cloudflare/AWS)    │
            │  - DDoS Protection          │
            │  - Bot Protection           │
            │  - OWASP Top 10             │
            └──────────────┬──────────────┘
                           │
            ┌──────────────▼──────────────┐
            │  APOLLO GATEWAY             │
            │  (GraphQL Federation)       │
            │  - Rate Limiting            │
            │  - JWT Validation           │
            │  - Query Complexity Limit   │
            └──────────────┬──────────────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
┌───────▼────────┐  ┌──────▼───────┐  ┌──────▼──────────┐
│ Microservicio  │  │ Microservicio│  │  Microservicio  │
│  Históricos    │  │ Transferencias│  │  Autenticación  │
│  (GraphQL)     │  │  (GraphQL +   │  │  (REST)         │
│  + Workers     │  │   SAGA)       │  │  + OAuth 2.0    │
└────────────────┘  └──────────────┘  └─────────────────┘
        │                  │                  │
        └──────────────────┼──────────────────┘
                           │
            ┌──────────────▼──────────────┐
            │  KAFKA MESSAGE BUS          │
            │  + ZooKeeper Cluster        │
            │  Topics: SAGA, Events, Logs │
            └─────────────────────────────┘
    </pre
      >
    </div>

    <h2>2.3 Justificación de Decisiones Arquitectónicas</h2>

    <div class="section">
      <div class="justification">
        <div class="justification-title">1. WAF (Web Application Firewall)</div>
        <p>
          <strong>Decisión:</strong> Cloudflare WAF o AWS WAF como primera línea
          de defensa
        </p>
        <p><strong>Justificación:</strong></p>
        <ul>
          <li>
            Protección contra ataques OWASP Top 10 (SQL Injection, XSS, CSRF)
          </li>
          <li>Mitigación de DDoS antes de que llegue a la infraestructura</li>
          <li>Detección y bloqueo de bots maliciosos</li>
          <li>Reducción de costos al filtrar tráfico malicioso temprano</li>
          <li>Cumplimiento de PCI DSS Requirement 6.6</li>
        </ul>
      </div>

      <div class="justification">
        <div class="justification-title">
          2. Apollo Gateway con GraphQL Federation
        </div>
        <p>
          <strong>Decisión:</strong> Punto único de entrada con GraphQL como
          protocolo principal (95%)
        </p>
        <p><strong>Justificación:</strong></p>
        <ul>
          <li>
            <strong>Eficiencia:</strong> Reducción de 60-70% en latencia vs
            múltiples requests REST
          </li>
          <li>
            <strong>Simplicidad:</strong> Un solo endpoint para todas las
            queries y mutations
          </li>
          <li>
            <strong>Seguridad centralizada:</strong> JWT validation, rate
            limiting en un solo lugar
          </li>
          <li>
            <strong>Query complexity analysis:</strong> Previene queries
            abusivas
          </li>
          <li>
            <strong>Escalabilidad:</strong> Facilita agregar nuevos
            microservicios sin cambiar frontend
          </li>
          <li>
            <strong>Mejor UX:</strong> Reducción de 65-70% en bandwidth
            consumido (crítico para mobile)
          </li>
        </ul>
      </div>

      <div class="justification">
        <div class="justification-title">3. Arquitectura de Microservicios</div>
        <p>
          <strong>Decisión:</strong> Separación en servicios independientes por
          dominio de negocio
        </p>
        <p><strong>Justificación:</strong></p>
        <ul>
          <li>
            <strong>Escalabilidad independiente:</strong> Cada servicio escala
            según su carga específica
          </li>
          <li>
            <strong>Despliegues independientes:</strong> Actualizar un servicio
            sin afectar los demás
          </li>
          <li>
            <strong>Resiliencia:</strong> Fallo de un servicio no tumba todo el
            sistema (bulkhead pattern)
          </li>
          <li>
            <strong>Tecnología específica:</strong> Elegir la mejor herramienta
            para cada problema
          </li>
          <li>
            <strong>Equipos autónomos:</strong> Cada equipo puede trabajar
            independientemente
          </li>
          <li>
            <strong>Facilita testing:</strong> Tests unitarios e integración más
            simples
          </li>
        </ul>
      </div>
    </div>

    <h2>2.4 Componentes Principales del Sistema</h2>

    <div class="section">
      <table>
        <thead>
          <tr>
            <th>Componente</th>
            <th>Tecnología</th>
            <th>Propósito</th>
            <th>Justificación</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Frontend Web</strong></td>
            <td>React 18+ SPA</td>
            <td>Interfaz de usuario web</td>
            <td>Ecosistema maduro, reutilización de componentes con móvil</td>
          </tr>
          <tr>
            <td><strong>Frontend Móvil</strong></td>
            <td>React Native 0.73+</td>
            <td>Apps iOS/Android</td>
            <td>Compartir código con web, menor time-to-market</td>
          </tr>
          <tr>
            <td><strong>API Gateway</strong></td>
            <td>Apollo Gateway</td>
            <td>Punto de entrada único</td>
            <td>GraphQL Federation, mejor que REST tradicional</td>
          </tr>
          <tr>
            <td><strong>Microservicios</strong></td>
            <td>Node.js + GraphQL</td>
            <td>Lógica de negocio</td>
            <td>Worker Threads para paralelismo, GraphQL eficiente</td>
          </tr>
          <tr>
            <td><strong>Message Bus</strong></td>
            <td>Apache Kafka</td>
            <td>Comunicación asíncrona</td>
            <td>Alta throughput, durabilidad, ideal para SAGA</td>
          </tr>
          <tr>
            <td><strong>Orquestador</strong></td>
            <td>Kubernetes</td>
            <td>Gestión de contenedores</td>
            <td>Autoescalado, self-healing, standard de industria</td>
          </tr>
          <tr>
            <td><strong>Bases de Datos</strong></td>
            <td>PostgreSQL + MongoDB</td>
            <td>Persistencia</td>
            <td>CQRS: PostgreSQL para escritura, MongoDB para lectura</td>
          </tr>
          <tr>
            <td><strong>Caché</strong></td>
            <td>Redis</td>
            <td>Caché + Sesiones + SAGA</td>
            <td>Performance, estado temporal de SAGAs</td>
          </tr>
          <tr>
            <td><strong>Observabilidad</strong></td>
            <td>ELK + Prometheus</td>
            <td>Logs + Métricas</td>
            <td>Stack estándar, integración con K8s</td>
          </tr>
        </tbody>
      </table>
    </div>

    <h2>2.5 Flujo de Datos Principal</h2>

    <div class="section">
      <div class="diagram">
        <div class="diagram-title">Flujo de Request Típico</div>
        <pre>
Usuario (App) → Solicita consulta de movimientos
    │
    ├─► GraphQL Query enviada via HTTPS
    │
    ▼
WAF → Valida origen, detecta patrones maliciosos
    │
    ├─► ✓ Request limpia
    │
    ▼
Apollo Gateway → Valida JWT, analiza complexity
    │
    ├─► Enruta a MS-Históricos (subgraph)
    │
    ▼
MS-Históricos → Consulta MongoDB (Read DB)
    │
    ├─► Caché hit en Redis (70% casos)
    ├─► Caché miss → Query a MongoDB
    │
    ▼
Respuesta → GraphQL response con solo campos solicitados
    │
    ├─► 4 KB de datos (vs 11 KB en REST)
    ├─► Latencia: 120ms (vs 350ms en REST)
    │
    ▼
Usuario recibe datos optimizados
        </pre>
      </div>
    </div>

    <h2>2.6 Principios Arquitectónicos</h2>

    <div class="section">
      <h3>2.6.1 Principios Fundamentales</h3>

      <ol>
        <li>
          <strong>API First con GraphQL:</strong>
          <p>
            Diseñar APIs antes de implementar, con GraphQL como protocolo
            principal para máxima eficiencia.
          </p>
        </li>

        <li>
          <strong>Desacoplamiento Total:</strong>
          <p>
            Microservicios independientes comunicados vía eventos asíncronos
            (Kafka).
          </p>
        </li>

        <li>
          <strong>Idempotencia:</strong>
          <p>
            Todas las operaciones críticas son idempotentes (pueden ejecutarse
            múltiples veces sin efectos adversos).
          </p>
        </li>

        <li>
          <strong>Observabilidad desde el Diseño:</strong>
          <p>
            Logs estructurados, métricas y traces implementados desde el primer
            día.
          </p>
        </li>

        <li>
          <strong>Security by Design:</strong>
          <p>Seguridad integrada en cada capa, no agregada después.</p>
        </li>

        <li>
          <strong>Fail Fast, Recover Faster:</strong>
          <p>Detectar fallos rápidamente y recuperarse automáticamente.</p>
        </li>
      </ol>

      <h3>2.6.2 Patrones Arquitectónicos Utilizados</h3>

      <table>
        <thead>
          <tr>
            <th>Patrón</th>
            <th>Aplicación</th>
            <th>Beneficio</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>CQRS</strong></td>
            <td>Separación lectura/escritura</td>
            <td>Optimización de performance en consultas</td>
          </tr>
          <tr>
            <td><strong>SAGA</strong></td>
            <td>Transacciones distribuidas</td>
            <td>Consistencia eventual con compensación</td>
          </tr>
          <tr>
            <td><strong>Event Sourcing</strong></td>
            <td>Auditoría y sincronización</td>
            <td>Trazabilidad completa, replay de eventos</td>
          </tr>
          <tr>
            <td><strong>Circuit Breaker</strong></td>
            <td>Llamadas entre servicios</td>
            <td>Previene cascading failures</td>
          </tr>
          <tr>
            <td><strong>Bulkhead</strong></td>
            <td>Aislamiento de recursos</td>
            <td>Fallo de un tipo de operación no afecta otros</td>
          </tr>
          <tr>
            <td><strong>API Gateway</strong></td>
            <td>Punto de entrada único</td>
            <td>Seguridad centralizada, routing inteligente</td>
          </tr>
          <tr>
            <td><strong>Database per Service</strong></td>
            <td>Cada microservicio su BD</td>
            <td>Independencia total, escalabilidad</td>
          </tr>
        </tbody>
      </table>
    </div>

    <h2>2.7 Capas de la Arquitectura</h2>

    <div class="section">
      <div class="diagram">
        <div class="diagram-title">Arquitectura en Capas</div>
        <pre>
┌─────────────────────────────────────────────────────┐
│ CAPA 1: PRESENTACIÓN                                │
│ - SPA React (Web)                                   │
│ - React Native (iOS/Android)                        │
│ - Apollo Client (GraphQL)                           │
└─────────────────────────────────────────────────────┘
                        │
┌─────────────────────────────────────────────────────┐
│ CAPA 2: API GATEWAY                                 │
│ - Apollo Gateway (GraphQL Federation)               │
│ - Kong/NGINX (REST endpoints)                       │
│ - Rate Limiting, Auth, Logging                      │
└─────────────────────────────────────────────────────┘
                        │
┌─────────────────────────────────────────────────────┐
│ CAPA 3: SERVICIOS DE APLICACIÓN                    │
│ - Microservicios Node.js                            │
│ - GraphQL APIs (95%)                                │
│ - REST APIs (5% - archivos, webhooks)              │
│ - Worker Threads para procesamiento paralelo        │
└─────────────────────────────────────────────────────┘
                        │
┌─────────────────────────────────────────────────────┐
│ CAPA 4: MENSAJERÍA                                  │
│ - Apache Kafka (Event Bus)                          │
│ - ZooKeeper (Coordinación)                          │
│ - Topics: SAGA, Audit, Sync, Notifications          │
└─────────────────────────────────────────────────────┘
                        │
┌─────────────────────────────────────────────────────┐
│ CAPA 5: PERSISTENCIA                                │
│ - PostgreSQL (Write DB - ACID)                      │
│ - MongoDB (Read DB - Optimizada)                    │
│ - Redis (Cache + Sessions + SAGA State)             │
│ - Elasticsearch (Logs + Auditoría)                  │
└─────────────────────────────────────────────────────┘
                        │
┌─────────────────────────────────────────────────────┐
│ CAPA 6: INFRAESTRUCTURA                             │
│ - Kubernetes (Orquestación)                         │
│ - Docker (Contenedores)                             │
│ - Prometheus + Grafana (Métricas)                   │
│ - ELK Stack (Logs)                                  │
└─────────────────────────────────────────────────────┘
        </pre>
      </div>
    </div>

    <h2>2.8 Consideraciones de Diseño</h2>

    <div class="section">
      <div class="success">
        <strong>✓ Decisiones Clave Validadas:</strong>
        <ul>
          <li>GraphQL como protocolo principal reduce latencia 60-70%</li>
          <li>Microservicios permiten escalabilidad independiente</li>
          <li>Kafka garantiza comunicación asíncrona confiable</li>
          <li>CQRS optimiza lecturas sin impactar escrituras</li>
          <li>Patrón SAGA permite transacciones distribuidas</li>
        </ul>
      </div>

      <div class="note">
        <strong>Nota Importante:</strong> Esta arquitectura está diseñada para
        crecer de 50,000 usuarios iniciales hasta 10M+ usuarios sin necesidad de
        re-arquitectura, solo agregando más nodos horizontalmente.
      </div>
    </div>

    <div class="footer">
      <p>Propuesta de Arquitectura - Sistema Bancario BP | Capítulo 2 de 17</p>
    </div>
  </body>
</html>
