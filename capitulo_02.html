<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cap√≠tulo 2 - Arquitectura General del Sistema</title>
    <link rel="stylesheet" href="styles.css" />
    <style>
      .table-container {
        overflow-x: auto;
      }

      .table-container tbody tr:nth-of-type(1) {
        background-color: hsl(210, 80%, 95%);
      }
      .table-container tbody tr:nth-of-type(2) {
        background-color: hsl(210, 80%, 96%);
      }
      .table-container tbody tr:nth-of-type(3) {
        background-color: hsl(210, 80%, 97%);
      }
      .table-container tbody tr:nth-of-type(4) {
        background-color: hsl(210, 80%, 98%);
      }
      .table-container tbody tr:nth-of-type(5) {
        background-color: hsl(210, 80%, 98.5%);
      }
      .table-container tbody tr:nth-of-type(6) {
        background-color: hsl(210, 80%, 99%);
      }
      .table-container tbody tr:nth-of-type(7) {
        background-color: hsl(210, 80%, 99.5%);
      }

      .table-container tbody tr td:first-child {
        font-weight: 500;
        color: #0056b3;
      }

      code {
        background-color: #e9ecef;
        padding: 2px 5px;
        border-radius: 4px;
        font-family: "SF Mono", "Fira Code", monospace;
      }

      .ddd-highlight {
        padding: 20px;
        border-radius: 8px;
        margin: 20px 0;
      }

      .hexagonal-box {
        border: 3px solid #667eea;
        padding: 15px;
        margin: 15px 0;
        border-radius: 8px;
        background: #f8f9ff;
      }

      .architecture-layer {
        border-left: 4px solid #667eea;
        padding-left: 15px;
        margin: 10px 0;
      }
    </style>
  </head>
  <body>
    <div class="nav-header">
      <h2>Cap√≠tulo 2: Arquitectura General del Sistema</h2>
      <div class="nav-buttons">
        <a href="capitulo_01.html" class="nav-btn">‚Üê Anterior</a>
        <a href="index.html" class="nav-btn">√çndice</a>
        <a href="capitulo_03.html" class="nav-btn">Siguiente ‚Üí</a>
      </div>
    </div>

    <h1>2. ARQUITECTURA GENERAL DEL SISTEMA</h1>

    <div class="ddd-highlight">
      <h2>üéØ Enfoque Arquitect√≥nico: Domain-Driven Design (DDD)</h2>
      <p>
        Este sistema est√° fundamentado en los principios de
        <strong>Domain-Driven Design (DDD)</strong> combinado con
        <strong>Arquitectura Hexagonal (Puertos y Adaptadores)</strong>. Cada
        microservicio representa un <strong>Bounded Context</strong> del dominio
        bancario, con su propio modelo de dominio, lenguaje ubicuo y reglas de
        negocio encapsuladas.
      </p>
      <p>
        <strong>Principio fundamental:</strong> El dominio de negocio est√° en el
        centro, completamente aislado de detalles t√©cnicos de infraestructura
        mediante puertos y adaptadores.
      </p>
    </div>

    <h2>2.1 Vista de Contexto</h2>

    <div class="section">
      <p>
        El sistema bancario BP permite a los usuarios gestionar sus finanzas
        mediante aplicaciones web (SPA) y m√≥vil, con las siguientes capacidades
        principales:
      </p>

      <ul>
        <li>
          <strong>Consulta de hist√≥rico de movimientos:</strong> Acceso a
          transacciones pasadas con filtros avanzados
        </li>
        <li>
          <strong>Transferencias intrabancarias:</strong> Pagos entre cuentas
          del mismo banco
        </li>
        <li>
          <strong>Transferencias interbancarias:</strong> Pagos a otros bancos
          con patr√≥n SAGA
        </li>
        <li>
          <strong>Consulta de datos b√°sicos:</strong> Informaci√≥n del cliente y
          productos
        </li>
        <li>
          <strong>Notificaciones en tiempo real:</strong> V√≠a GraphQL
          Subscriptions y Push/SMS
        </li>
        <li>
          <strong>Autenticaci√≥n biom√©trica:</strong> Face ID, Touch ID y m√©todos
          tradicionales
        </li>
      </ul>
    </div>

    <h2>2.2 Contextos Delimitados (Bounded Contexts) - DDD</h2>

    <div class="section">
      <div class="hexagonal-box">
        <h3>üî∑ ¬øQu√© es un Bounded Context?</h3>
        <p>
          En DDD, un <strong>Bounded Context</strong> es una frontera expl√≠cita
          dentro de la cual un modelo de dominio espec√≠fico es v√°lido. Cada
          contexto tiene su propio lenguaje ubicuo (Ubiquitous Language) y sus
          propias reglas de negocio.
        </p>
        <p>
          <strong
            >En nuestro sistema bancario, identificamos 3 Bounded Contexts
            principales:</strong
          >
        </p>
      </div>

      <table>
        <thead>
          <tr>
            <th>Bounded Context</th>
            <th>Responsabilidad de Dominio</th>
            <th>Entidades Principales</th>
            <th>Lenguaje Ubicuo</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Context: Hist√≥ricos</strong></td>
            <td>Gesti√≥n de consultas y reportes de transacciones hist√≥ricas</td>
            <td>Transaction, AccountStatement, MovementFilter</td>
            <td>Movimiento, Saldo, Per√≠odo, Filtro</td>
          </tr>
          <tr>
            <td><strong>Context: Transferencias</strong></td>
            <td>
              Ejecuci√≥n de transferencias bancarias con consistencia
              transaccional
            </td>
            <td>Transfer, Account, TransferSaga, Compensation</td>
            <td>Transferencia, D√©bito, Cr√©dito, Compensaci√≥n</td>
          </tr>
          <tr>
            <td><strong>Context: Autenticaci√≥n</strong></td>
            <td>Control de acceso, identidad y autorizaci√≥n de usuarios</td>
            <td>User, Session, BiometricCredential, Token</td>
            <td>Usuario, Sesi√≥n, Credencial, Autenticaci√≥n</td>
          </tr>
        </tbody>
      </table>

      <div class="note">
        <strong>Nota DDD:</strong> Cada Bounded Context se implementa como un
        microservicio independiente con su propia base de datos, garantizando la
        autonom√≠a del dominio y evitando el acoplamiento de modelos.
      </div>
    </div>

    <h2>2.3 Arquitectura Hexagonal (Puertos y Adaptadores)</h2>

    <div class="section">
      <div class="hexagonal-box">
        <h3>‚¨° Arquitectura Hexagonal en cada Microservicio</h3>
        <p>
          Cada Bounded Context (microservicio) sigue la
          <strong>Arquitectura Hexagonal</strong>, que separa el dominio de
          negocio de los detalles de infraestructura mediante:
        </p>
        <ul>
          <li>
            <strong>Dominio (Centro):</strong> Entidades, Value Objects,
            Agregados, Domain Services
          </li>
          <li>
            <strong>Puertos:</strong> Interfaces que definen c√≥mo el dominio
            interact√∫a con el exterior
          </li>
          <li>
            <strong>Adaptadores:</strong> Implementaciones concretas de los
            puertos (GraphQL, REST, Kafka, Bases de Datos)
          </li>
        </ul>
      </div>

      <div class="architecture-layer">
        <h4>üîπ Capa de Dominio (Core)</h4>
        <p>
          <strong>Responsabilidad:</strong> L√≥gica de negocio pura,
          independiente de frameworks y tecnolog√≠a.
        </p>
        <p><strong>Componentes:</strong></p>
        <ul>
          <li>
            <strong>Entidades:</strong> Objetos con identidad √∫nica (ej:
            Transfer, Account, User)
          </li>
          <li>
            <strong>Value Objects:</strong> Objetos inmutables sin identidad
            (ej: Money, AccountNumber, Email)
          </li>
          <li>
            <strong>Agregados:</strong> Conjuntos de entidades con un root (ej:
            TransferAggregate)
          </li>
          <li>
            <strong>Domain Events:</strong> Eventos que representan hechos del
            negocio (ej: TransferCompleted)
          </li>
          <li>
            <strong>Domain Services:</strong> L√≥gica que no pertenece a una
            entidad espec√≠fica
          </li>
        </ul>
      </div>

      <div class="architecture-layer">
        <h4>üîπ Puertos (Interfaces)</h4>
        <p>
          <strong>Responsabilidad:</strong> Contratos que definen c√≥mo el
          dominio se comunica con el exterior.
        </p>
        <p><strong>Tipos de Puertos:</strong></p>
        <ul>
          <li>
            <strong>Puertos de Entrada (Driving/Primary):</strong> Casos de uso
            que el exterior invoca (ej: TransferUseCase)
          </li>
          <li>
            <strong>Puertos de Salida (Driven/Secondary):</strong> Interfaces
            que el dominio necesita (ej: TransferRepository, EventPublisher)
          </li>
        </ul>
      </div>

      <div class="architecture-layer">
        <h4>üîπ Adaptadores</h4>
        <p>
          <strong>Responsabilidad:</strong> Implementaciones concretas de los
          puertos, conectando el dominio con tecnolog√≠as espec√≠ficas.
        </p>
        <p><strong>Tipos de Adaptadores:</strong></p>
        <ul>
          <li>
            <strong>Adaptadores de Entrada:</strong> GraphQL Resolvers, REST
            Controllers, Kafka Consumers
          </li>
          <li>
            <strong>Adaptadores de Salida:</strong> PostgreSQL Repository,
            MongoDB Repository, Kafka Producer, Redis Cache
          </li>
        </ul>
      </div>

      <div class="success">
        <strong>‚úì Beneficios de Arquitectura Hexagonal:</strong>
        <ul>
          <li>Dominio completamente testeable sin dependencias externas</li>
          <li>Cambiar tecnolog√≠as (BD, API) sin tocar l√≥gica de negocio</li>
          <li>Facilita testing con mocks de adaptadores</li>
          <li>Mantiene el foco en el dominio, no en la tecnolog√≠a</li>
        </ul>
      </div>
    </div>

    <h2>2.4 Diagrama de Contexto</h2>

    <div class="diagram">
      <div class="diagram-title">
        Arquitectura de Alto Nivel (Bounded Contexts + Hexagonal)
      </div>
      <pre class="mermaid">
flowchart TD
  Users["USUARIOS FINALES"]
  WebSPA["SPA&nbsp;Web&nbsp;(ReactJS)<br/>
            [Adaptador: UI]"]
  MobileApp["App&nbsp;M√≥vil&nbsp;(React&nbsp;Native)<br/>
            [Adaptador: UI]"]
  WAF["WAF (Cloudflare/AWS) 
       - DDoS Protection
       - Bot Protection
       - OWASP Top 10"]
  Gateway["APOLLO GATEWAY<br/>
       .GraphQL Federation<br/>
       .Puerto&nbsp;de&nbsp;Entrada&nbsp;Principal<br/>"]
  
  subgraph BC1["üî∑ BOUNDED CONTEXT: HIST√ìRICOS"]
    MS1["Microservicio&nbsp;Hist√≥ricos
          [Arquitectura Hexagonal]
          ‚Ä¢ Dominio: Transactions
          ‚Ä¢ Puertos: Queries
          ‚Ä¢ Adaptadores: GraphQL, MongoDB"]
  end
  
  subgraph BC2["üî∑ BOUNDED CONTEXT: TRANSFERENCIAS"]
    MS2["Microservicio&nbsp;Transferencias
    [Arquitectura Hexagonal]
    ‚Ä¢ Dominio: Transfers + SAGA
    ‚Ä¢ Puertos: Commands
    ‚Ä¢ Adaptadores: GraphQL, PostgreSQL, Kafka"]
  end
  
  subgraph BC3["üî∑ BOUNDED CONTEXT: AUTENTICACI√ìN"]
    MS3["Microservicio&nbsp;Autenticaci√≥n
    [Arquitectura Hexagonal]
    ‚Ä¢ Dominio: Identity
    ‚Ä¢ Puertos: AuthService
    ‚Ä¢ Adaptadores: REST, OAuth 2.0"]
  end
  
  Kafka["KAFKA MESSAGE BUS
          [Adaptador&nbsp;de&nbsp;Comunicaci√≥n]
            Topics:&nbsp;SAGA,&nbsp;Domain&nbsp;Events,&nbsp;Logs"]

  Users --> WebSPA & MobileApp
  WebSPA & MobileApp -->|HTTPS/TLS 1.3| WAF
  WAF --> Gateway
  Gateway --> MS1 & MS2 & MS3
  MS1 & MS2 & MS3 --> Kafka

  classDef default fill:#f9f9f9,stroke:#333,stroke-width:2px;
  classDef gateway fill:#e1f3d8,stroke:#82c91e;
  classDef services fill:#d0ebff,stroke:#339af0;
  classDef messaging fill:#fff3bf,stroke:#f59f00;

  class WAF,Gateway gateway;
  class MS1,MS2,MS3 services;
  class Kafka messaging;
  </pre>
    </div>

    <h2>2.5 Justificaci√≥n de Decisiones Arquitect√≥nicas</h2>

    <div class="section">
      <div class="justification">
        <div class="justification-title">1. Domain-Driven Design (DDD)</div>
        <p>
          <strong>Decisi√≥n:</strong> Adoptar DDD como filosof√≠a de dise√±o
          principal
        </p>
        <p><strong>Justificaci√≥n:</strong></p>
        <ul>
          <li>
            <strong>Complejidad del dominio bancario:</strong> DDD es ideal para
            dominios complejos con muchas reglas de negocio
          </li>
          <li>
            <strong>Lenguaje ubicuo:</strong> Desarrolladores y expertos del
            dominio hablan el mismo idioma
          </li>
          <li>
            <strong>Bounded Contexts:</strong> Permite dividir el sistema en
            partes manejables e independientes
          </li>
          <li>
            <strong>Evoluci√≥n controlada:</strong> Cambios en un contexto no
            afectan otros
          </li>
          <li>
            <strong>Testing simplificado:</strong> Dominio puro sin dependencias
            externas
          </li>
        </ul>
      </div>

      <div class="justification">
        <div class="justification-title">
          2. Arquitectura Hexagonal (Puertos y Adaptadores)
        </div>
        <p>
          <strong>Decisi√≥n:</strong> Implementar arquitectura hexagonal en cada
          microservicio
        </p>
        <p><strong>Justificaci√≥n:</strong></p>
        <ul>
          <li>
            <strong>Independencia tecnol√≥gica:</strong> Cambiar BD o API sin
            tocar dominio
          </li>
          <li>
            <strong>Testabilidad:</strong> Probar l√≥gica de negocio sin
            infraestructura
          </li>
          <li>
            <strong>Mantenibilidad:</strong> Dominio aislado facilita cambios
          </li>
          <li>
            <strong>Flexibilidad:</strong> Agregar nuevos adaptadores sin
            modificar dominio
          </li>
          <li>
            <strong>Claridad:</strong> Separaci√≥n expl√≠cita de responsabilidades
          </li>
        </ul>
      </div>

      <div class="justification">
        <div class="justification-title">3. WAF (Web Application Firewall)</div>
        <p>
          <strong>Decisi√≥n:</strong> Cloudflare WAF o AWS WAF como primera l√≠nea
          de defensa
        </p>
        <p><strong>Justificaci√≥n:</strong></p>
        <ul>
          <li>
            Protecci√≥n contra ataques OWASP Top 10 (SQL Injection, XSS, CSRF)
          </li>
          <li>Mitigaci√≥n de DDoS antes de que llegue a la infraestructura</li>
          <li>Detecci√≥n y bloqueo de bots maliciosos</li>
          <li>Reducci√≥n de costos al filtrar tr√°fico malicioso temprano</li>
          <li>Cumplimiento de PCI DSS Requirement 6.6</li>
        </ul>
      </div>

      <div class="justification">
        <div class="justification-title">
          4. Apollo Gateway con GraphQL Federation
        </div>
        <p>
          <strong>Decisi√≥n:</strong> Punto √∫nico de entrada con GraphQL como
          protocolo principal (95%)
        </p>
        <p><strong>Justificaci√≥n:</strong></p>
        <ul>
          <li>
            <strong>Eficiencia:</strong> Reducci√≥n de 60-70% en latencia vs
            m√∫ltiples requests REST
          </li>
          <li>
            <strong>Simplicidad:</strong> Un solo endpoint para todas las
            queries y mutations
          </li>
          <li>
            <strong>Seguridad centralizada:</strong> JWT validation, rate
            limiting en un solo lugar
          </li>
          <li>
            <strong>Query complexity analysis:</strong> Previene queries
            abusivas
          </li>
          <li>
            <strong>Escalabilidad:</strong> Facilita agregar nuevos
            microservicios sin cambiar frontend
          </li>
          <li>
            <strong>Mejor UX:</strong> Reducci√≥n de 65-70% en bandwidth
            consumido (cr√≠tico para mobile)
          </li>
        </ul>
      </div>

      <div class="justification">
        <div class="justification-title">
          5. Microservicios por Bounded Context
        </div>
        <p>
          <strong>Decisi√≥n:</strong> Cada Bounded Context es un microservicio
          independiente
        </p>
        <p><strong>Justificaci√≥n:</strong></p>
        <ul>
          <li>
            <strong>Alineaci√≥n DDD:</strong> Un microservicio = Un Bounded
            Context
          </li>
          <li>
            <strong>Escalabilidad independiente:</strong> Cada servicio escala
            seg√∫n su carga espec√≠fica
          </li>
          <li>
            <strong>Despliegues independientes:</strong> Actualizar un servicio
            sin afectar los dem√°s
          </li>
          <li>
            <strong>Resiliencia:</strong> Fallo de un servicio no tumba todo el
            sistema (bulkhead pattern)
          </li>
          <li>
            <strong>Tecnolog√≠a espec√≠fica:</strong> Elegir la mejor herramienta
            para cada problema
          </li>
          <li>
            <strong>Equipos aut√≥nomos:</strong> Cada equipo trabaja en su
            contexto
          </li>
        </ul>
      </div>
    </div>

    <h2>2.6 Componentes Principales del Sistema</h2>

    <div class="section">
      <table>
        <thead>
          <tr>
            <th>Componente</th>
            <th>Tecnolog√≠a</th>
            <th>Prop√≥sito</th>
            <th>Justificaci√≥n</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Frontend Web</strong></td>
            <td>React 18+ SPA</td>
            <td>Interfaz de usuario web</td>
            <td>Ecosistema maduro, reutilizaci√≥n de componentes con m√≥vil</td>
          </tr>
          <tr>
            <td><strong>Frontend M√≥vil</strong></td>
            <td>React Native 0.73+</td>
            <td>Apps iOS/Android</td>
            <td>Compartir c√≥digo con web, menor time-to-market</td>
          </tr>
          <tr>
            <td><strong>API Gateway</strong></td>
            <td>Apollo Gateway</td>
            <td>Punto de entrada √∫nico</td>
            <td>GraphQL Federation, mejor que REST tradicional</td>
          </tr>
          <tr>
            <td><strong>Microservicios</strong></td>
            <td>Node.js + GraphQL</td>
            <td>L√≥gica de negocio (Dominio DDD)</td>
            <td>Worker Threads para paralelismo, GraphQL eficiente</td>
          </tr>
          <tr>
            <td><strong>Message Bus</strong></td>
            <td>Apache Kafka</td>
            <td>Comunicaci√≥n as√≠ncrona entre contexts</td>
            <td>
              Alta throughput, durabilidad, ideal para SAGA y Domain Events
            </td>
          </tr>
          <tr>
            <td><strong>Orquestador</strong></td>
            <td>Kubernetes</td>
            <td>Gesti√≥n de contenedores</td>
            <td>Autoescalado, self-healing, standard de industria</td>
          </tr>
          <tr>
            <td><strong>Bases de Datos</strong></td>
            <td>PostgreSQL + MongoDB</td>
            <td>Persistencia (Database per Service)</td>
            <td>CQRS: PostgreSQL para escritura, MongoDB para lectura</td>
          </tr>
          <tr>
            <td><strong>Cach√©</strong></td>
            <td>Redis</td>
            <td>Cach√© + Sesiones + SAGA State</td>
            <td>Performance, estado temporal de SAGAs</td>
          </tr>
          <tr>
            <td><strong>Observabilidad</strong></td>
            <td>ELK + Prometheus</td>
            <td>Logs + M√©tricas</td>
            <td>Stack est√°ndar, integraci√≥n con K8s</td>
          </tr>
        </tbody>
      </table>
    </div>

    <h2>2.7 Flujo de Datos Principal</h2>

    <div class="section">
      <div class="diagram">
        <div class="diagram-title">
          Flujo de Request T√≠pico (Arquitectura Hexagonal)
        </div>
        <pre class="mermaid">
sequenceDiagram
  actor U as Usuario (App)
  participant A as Adaptador UI
  participant W as WAF
  participant AG as Apollo Gateway (Puerto)
  participant GR as GraphQL Resolver (Adaptador Entrada)
  participant UC as Use Case (Puerto Entrada)
  participant DS as Domain Service (Dominio)
  participant RP as Repository Port (Puerto Salida)
  participant DB as DB Adapter (Adaptador Salida)
  participant Cache as Redis Cache

  U->>A: Solicita movimientos
  A->>W: GraphQL Query (HTTPS)
  Note over W: Valida seguridad
  
  W->>AG: ‚úì Request limpia
  Note over AG: Puerto de entrada principal<br/>Valida JWT
  
  AG->>GR: Enruta query
  Note over GR: Adaptador de entrada GraphQL
  
  GR->>UC: Ejecuta caso de uso
  Note over UC: Puerto de entrada<br/>GetAccountMovements
  
  UC->>DS: Aplica l√≥gica dominio
  Note over DS: DOMINIO PURO<br/>Reglas de negocio
  
  DS->>RP: Solicita datos
  Note over RP: Puerto de salida<br/>TransactionRepository interface
  
  RP->>Cache: Intenta cache
  Cache-->>RP: Cache miss
  
  RP->>DB: Query BD
  Note over DB: Adaptador MongoDB<br/>Implementa Repository Port
  
  DB-->>RP: Retorna datos
  RP-->>DS: Entities de dominio
  DS-->>UC: Datos procesados
  UC-->>GR: DTO de salida
  GR-->>AG: GraphQL response
  AG-->>W: Datos optimizados
  W-->>A: 4 KB vs 11 KB REST
  A-->>U: Renderiza UI
  Note over U: 120ms vs 350ms latencia
    </pre>
      </div>

      <div class="note">
        <strong>Nota Arquitect√≥nica:</strong> Observa c√≥mo el flujo pasa por
        capas bien definidas:
        <ul>
          <li>
            <strong>Adaptadores de Entrada:</strong> GraphQL Resolver recibe el
            request
          </li>
          <li>
            <strong>Puerto de Entrada:</strong> Use Case define el contrato
          </li>
          <li>
            <strong>Dominio:</strong> L√≥gica de negocio pura, sin dependencias
            externas
          </li>
          <li><strong>Puerto de Salida:</strong> Interface Repository</li>
          <li>
            <strong>Adaptador de Salida:</strong> Implementaci√≥n concreta
            (MongoDB, Redis)
          </li>
        </ul>
      </div>
    </div>

    <h2>2.8 Principios Arquitect√≥nicos</h2>

    <div class="section">
      <h3>2.8.1 Principios Fundamentales DDD</h3>

      <ol>
        <li>
          <strong>Ubiquitous Language (Lenguaje Ubicuo):</strong>
          <p>
            El c√≥digo usa exactamente los mismos t√©rminos que los expertos del
            dominio. No hay traducci√≥n entre negocio y t√©cnico: "Transfer",
            "Account", "Compensation" son nombres tanto en el c√≥digo como en las
            conversaciones de negocio.
          </p>
        </li>

        <li>
          <strong>Bounded Contexts Independientes:</strong>
          <p>
            Cada contexto (Hist√≥ricos, Transferencias, Autenticaci√≥n) tiene su
            propio modelo y no comparte entidades con otros contextos. La
            comunicaci√≥n es via Domain Events.
          </p>
        </li>

        <li>
          <strong>Domain at the Core (Dominio en el Centro):</strong>
          <p>
            La l√≥gica de negocio est√° completamente aislada de frameworks, bases
            de datos, y APIs. El dominio no conoce GraphQL, ni PostgreSQL, ni
            Kafka.
          </p>
        </li>

        <li>
          <strong>Agregados con Ra√≠z:</strong>
          <p>
            Conjuntos de entidades relacionadas se agrupan en Agregados con una
            ra√≠z que garantiza la consistencia. Ejemplo: TransferAggregate
            controla Transfer + TransferLine.
          </p>
        </li>

        <li>
          <strong>Domain Events:</strong>
          <p>
            Los hechos importantes del dominio se modelan como eventos:
            TransferCompleted, AccountDebited, CompensationTriggered. Facilitan
            comunicaci√≥n entre contextos.
          </p>
        </li>
      </ol>

      <h3>2.8.2 Principios de Arquitectura Hexagonal</h3>

      <ol>
        <li>
          <strong>Dependency Inversion:</strong>
          <p>
            El dominio define interfaces (puertos), y la infraestructura las
            implementa (adaptadores). Nunca al rev√©s. El dominio no depende de
            nadie.
          </p>
        </li>

        <li>
          <strong>Ports and Adapters:</strong>
          <p>
            Toda comunicaci√≥n con el exterior se hace mediante puertos
            (interfaces) y adaptadores (implementaciones). Podemos cambiar de
            GraphQL a gRPC sin tocar el dominio.
          </p>
        </li>

        <li>
          <strong>Testabilidad Total:</strong>
          <p>
            El dominio se testea con mocks de puertos, sin necesidad de levantar
            bases de datos o servidores. Tests r√°pidos y confiables.
          </p>
        </li>
      </ol>

      <h3>2.8.3 Otros Principios Arquitect√≥nicos</h3>

      <ol>
        <li>
          <strong>API First con GraphQL:</strong>
          <p>
            Dise√±ar APIs antes de implementar, con GraphQL como protocolo
            principal para m√°xima eficiencia.
          </p>
        </li>

        <li>
          <strong>Idempotencia:</strong>
          <p>
            Todas las operaciones cr√≠ticas son idempotentes (pueden ejecutarse
            m√∫ltiples veces sin efectos adversos).
          </p>
        </li>

        <li>
          <strong>Observabilidad desde el Dise√±o:</strong>
          <p>
            Logs estructurados, m√©tricas y traces implementados desde el primer
            d√≠a.
          </p>
        </li>

        <li>
          <strong>Security by Design:</strong>
          <p>Seguridad integrada en cada capa, no agregada despu√©s.</p>
        </li>

        <li>
          <strong>Fail Fast, Recover Faster:</strong>
          <p>Detectar fallos r√°pidamente y recuperarse autom√°ticamente.</p>
        </li>
      </ol>

      <h3>2.8.4 Patrones Arquitect√≥nicos Utilizados</h3>

      <table>
        <thead>
          <tr>
            <th>Patr√≥n</th>
            <th>Aplicaci√≥n</th>
            <th>Beneficio</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Bounded Context</strong></td>
            <td>Divisi√≥n del sistema en contextos</td>
            <td>Modelos de dominio independientes y mantenibles</td>
          </tr>
          <tr>
            <td><strong>Hexagonal Architecture</strong></td>
            <td>Estructura interna de microservicios</td>
            <td>Dominio aislado de tecnolog√≠a</td>
          </tr>
          <tr>
            <td><strong>CQRS</strong></td>
            <td>Separaci√≥n lectura/escritura</td>
            <td>Optimizaci√≥n de performance en consultas</td>
          </tr>
          <tr>
            <td><strong>SAGA</strong></td>
            <td>Transacciones distribuidas</td>
            <td>Consistencia eventual con compensaci√≥n</td>
          </tr>
          <tr>
            <td><strong>Event Sourcing</strong></td>
            <td>Auditor√≠a y sincronizaci√≥n</td>
            <td>Trazabilidad completa, replay de eventos</td>
          </tr>
          <tr>
            <td><strong>Domain Events</strong></td>
            <td>Comunicaci√≥n entre Bounded Contexts</td>
            <td>Desacoplamiento total entre contextos</td>
          </tr>
          <tr>
            <td><strong>Circuit Breaker</strong></td>
            <td>Llamadas entre servicios</td>
            <td>Previene cascading failures</td>
          </tr>
          <tr>
            <td><strong>Bulkhead</strong></td>
            <td>Aislamiento de recursos</td>
            <td>Fallo de un tipo de operaci√≥n no afecta otros</td>
          </tr>
          <tr>
            <td><strong>API Gateway</strong></td>
            <td>Punto de entrada √∫nico</td>
            <td>Seguridad centralizada, routing inteligente</td>
          </tr>
          <tr>
            <td><strong>Database per Service</strong></td>
            <td>Cada microservicio su BD</td>
            <td>Independencia total, escalabilidad</td>
          </tr>
        </tbody>
      </table>
    </div>

    <h2>2.9 Capas de la Arquitectura (Visi√≥n Macro)</h2>

    <div class="section">
      <div class="table-container">
        <table>
          <thead>
            <tr>
              <th>Capa</th>
              <th>Responsabilidad Principal</th>
              <th>Tecnolog√≠as Clave</th>
              <th>Flujo / Interacciones</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><b>Capa 1: Presentaci√≥n</b> üñºÔ∏è</td>
              <td>
                Interfaz con la que interact√∫a el usuario final (Cliente
                Web/M√≥vil). <strong>[Adaptador de UI]</strong>
              </td>
              <td>
                <code>React</code>, <code>React Native</code>,
                <code>Apollo Client</code>
              </td>
              <td>Env√≠a peticiones del usuario hacia el API Gateway.</td>
            </tr>
            <tr>
              <td><b>Capa 2: API Gateway</b> üö™</td>
              <td>
                Punto de entrada √∫nico que gestiona la seguridad y el
                enrutamiento. <strong>[Puerto Principal]</strong>
              </td>
              <td>
                <code>Apollo Gateway</code>, <code>Kong</code>,
                <code>NGINX</code>
              </td>
              <td>
                Recibe peticiones de la Capa 1 y las dirige a los servicios
                correspondientes.
              </td>
            </tr>
            <tr>
              <td><b>Capa 3: Bounded Contexts</b> üß†</td>
              <td>
                Microservicios con arquitectura hexagonal. Contienen dominio +
                puertos + adaptadores. <strong>[Microservicios DDD]</strong>
              </td>
              <td><code>Microservicios en Node.js</code></td>
              <td>
                Recibe peticiones del API Gateway y utiliza las capas de
                Mensajer√≠a y Persistencia.
              </td>
            </tr>
            <tr>
              <td><b>Capa 4: Mensajer√≠a</b> üì®</td>
              <td>
                Gestiona comunicaci√≥n as√≠ncrona y Domain Events entre Bounded
                Contexts.
                <strong>[Adaptador de Comunicaci√≥n]</strong>
              </td>
              <td><code>Apache Kafka</code></td>
              <td>
                Es utilizada por los Bounded Contexts para publicar/consumir
                Domain Events.
              </td>
            </tr>
            <tr>
              <td><b>Capa 5: Persistencia</b> üíæ</td>
              <td>
                Almacenamiento y recuperaci√≥n de datos. Cada contexto tiene su
                propia BD.
                <strong>[Adaptadores de BD]</strong>
              </td>
              <td><code>PostgreSQL, MongoDB, Redis</code></td>
              <td>
                Provee los datos que los Domain Services necesitan para operar.
              </td>
            </tr>
            <tr>
              <td><b>Capa 6: Infraestructura</b> üèóÔ∏è</td>
              <td>
                Orquesta y ejecuta todos los servicios del backend en
                contenedores.
              </td>
              <td><code>Kubernetes</code>, <code>Docker</code></td>
              <td>
                Es la base sobre la que se despliegan y operan las capas 3, 4 y
                5.
              </td>
            </tr>
            <tr>
              <td><b>Capa Transversal: Observabilidad</b> üìä</td>
              <td>Monitorea la salud y el rendimiento de todo el sistema.</td>
              <td>
                <code>Prometheus</code>, <code>Grafana</code>,
                <code>ELK Stack</code>
              </td>
              <td>
                Recopila m√©tricas y logs de todas las dem√°s capas para an√°lisis
                y alertas.
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

    <h2>2.10 Estructura de un Microservicio (Ejemplo: Transferencias)</h2>

    <div class="section">
      <div class="hexagonal-box">
        <h3>‚¨° Anatom√≠a de un Bounded Context con Arquitectura Hexagonal</h3>
        <p>
          Cada microservicio sigue esta estructura de carpetas que refleja las
          capas hexagonales:
        </p>
      </div>

      <div class="code-section">
        <pre><code>ms-transferencias/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ domain/                    # üü¶ CAPA DE DOMINIO (Centro del Hex√°gono)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ entities/              # Entidades con identidad
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Transfer.ts        # Entidad Transfer
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Account.ts         # Entidad Account
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TransferLine.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ value-objects/         # Objetos de valor inmutables
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Money.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AccountNumber.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TransferId.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ aggregates/            # Ra√≠ces de agregado
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TransferAggregate.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ events/                # Domain Events
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TransferCreated.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TransferCompleted.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CompensationTriggered.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/              # Domain Services
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TransferValidator.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CompensationService.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ exceptions/            # Excepciones de dominio
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ InsufficientFundsError.ts
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ application/               # üü© PUERTOS (Casos de Uso)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ports/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ in/               # Puertos de Entrada (Driving)
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CreateTransferUseCase.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CancelTransferUseCase.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ GetTransferStatusUseCase.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ out/              # Puertos de Salida (Driven)
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ TransferRepository.ts      # Interface
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ AccountRepository.ts       # Interface
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ EventPublisher.ts          # Interface
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ SagaStateRepository.ts     # Interface
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dto/                  # üì¶ DTOs (Data Transfer Objects)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CreateTransferDto.ts          # Input DTO
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TransferResponseDto.ts        # Output DTO
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CancelTransferDto.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TransferStatusDto.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mappers/              # Mappers: DTO ‚Üî Domain Entity
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TransferMapper.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ AccountMapper.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ usecases/             # Implementaci√≥n de casos de uso
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ CreateTransferUseCaseImpl.ts
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ CancelTransferUseCaseImpl.ts
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ infrastructure/            # üü® ADAPTADORES
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ adapters/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ in/               # Adaptadores de Entrada
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ graphql/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TransferResolver.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ schema.graphql
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ kafka/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ TransferEventConsumer.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ out/              # Adaptadores de Salida
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ postgres/
‚îÇ   ‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ PostgresTransferRepository.ts
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ kafka/
‚îÇ   ‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ KafkaEventPublisher.ts
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ redis/
‚îÇ   ‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ RedisSagaStateRepository.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config/               # Configuraci√≥n
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ database.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ kafka.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ migrations/           # Migraciones de BD
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ shared/                   # C√≥digo compartido
‚îÇ       ‚îú‚îÄ‚îÄ utils/
‚îÇ       ‚îî‚îÄ‚îÄ types/
‚îÇ
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ unit/                     # Tests del dominio (puros)
‚îÇ   ‚îú‚îÄ‚îÄ integration/              # Tests de adaptadores
‚îÇ   ‚îî‚îÄ‚îÄ e2e/                      # Tests end-to-end
‚îÇ
‚îî‚îÄ‚îÄ package.json</code></pre>
      </div>

      <div class="note">
        <strong>üì¶ Sobre los DTOs (Data Transfer Objects):</strong>
        <p>
          Los DTOs son objetos simples que transfieren datos entre capas. Son
          cruciales en arquitectura hexagonal porque:
        </p>
        <ul>
          <li>
            <strong>Desacoplan el dominio de las APIs:</strong> El dominio no
            conoce GraphQL, REST o Kafka
          </li>
          <li>
            <strong>Control de datos expuestos:</strong> Solo se expone lo que
            el API necesita, no toda la entidad
          </li>
          <li>
            <strong>Validaci√≥n en el borde:</strong> Los DTOs validan datos
            antes de llegar al dominio
          </li>
          <li>
            <strong>Versionado independiente:</strong> Cambiar API sin cambiar
            dominio
          </li>
        </ul>
        <p>
          <strong>Flujo t√≠pico:</strong>
          GraphQL Request ‚Üí DTO ‚Üí Mapper ‚Üí Domain Entity ‚Üí Use Case ‚Üí Domain
          Entity ‚Üí Mapper ‚Üí DTO ‚Üí GraphQL Response
        </p>

        <p><strong>Ejemplo pr√°ctico:</strong></p>
        <pre
          style="
            background: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
          "
        ><code>// 1. GraphQL Resolver recibe el request (Adaptador de Entrada)
async createTransfer(args: CreateTransferInput) {
  // 2. Convierte input a DTO
  const dto = new CreateTransferDto(args);
  
  // 3. Mapper convierte DTO ‚Üí Domain Entity
  const transfer = TransferMapper.toDomain(dto);
  
  // 4. Ejecuta caso de uso con entidad de dominio
  const result = await createTransferUseCase.execute(transfer);
  
  // 5. Mapper convierte Domain Entity ‚Üí DTO de respuesta
  const responseDto = TransferMapper.toDto(result);
  
  // 6. Retorna DTO al cliente
  return responseDto;
}</code></pre>
      </div>

      <div class="success">
        <strong>‚úì Ventajas de esta estructura:</strong>
        <ul>
          <li>
            <strong>Claridad:</strong> Es evidente qu√© es dominio, qu√© son
            puertos y qu√© son adaptadores
          </li>
          <li>
            <strong>Testabilidad:</strong> El dominio se testea sin dependencias
            externas
          </li>
          <li>
            <strong>Mantenibilidad:</strong> Cambios en infraestructura no
            afectan dominio
          </li>
          <li>
            <strong>Onboarding:</strong> Nuevos desarrolladores entienden la
            estructura r√°pidamente
          </li>
        </ul>
      </div>
    </div>

    <h2>2.11 Consideraciones de Dise√±o</h2>

    <div class="section">
      <div class="success">
        <strong>‚úì Decisiones Clave Validadas:</strong>
        <ul>
          <li>
            <strong>DDD + Hexagonal:</strong> Dominio en el centro, tecnolog√≠a
            en la periferia
          </li>
          <li>
            <strong>Bounded Contexts independientes:</strong> Cada contexto
            evoluciona sin afectar otros
          </li>
          <li>
            <strong>GraphQL como protocolo principal</strong> reduce latencia
            60-70%
          </li>
          <li>
            <strong>Kafka para Domain Events</strong> permite comunicaci√≥n
            as√≠ncrona entre contextos
          </li>
          <li>
            <strong>CQRS optimiza lecturas</strong> sin impactar escrituras
          </li>
          <li>
            <strong>Patr√≥n SAGA</strong> permite transacciones distribuidas con
            compensaci√≥n
          </li>
          <li>
            <strong>Database per Service</strong> garantiza independencia total
            de cada contexto
          </li>
        </ul>
      </div>

      <div class="note">
        <strong>Nota Importante sobre DDD:</strong> Esta arquitectura no es solo
        sobre tecnolog√≠a, es sobre modelar el dominio de negocio correctamente.
        El c√≥digo refleja exactamente c√≥mo funciona el negocio bancario, usando
        el mismo lenguaje que los expertos del dominio. Los cambios en el
        negocio se traducen directamente a cambios en el c√≥digo del dominio, sin
        necesidad de tocar infraestructura.
      </div>

      <div class="note">
        <strong>Escalabilidad:</strong> Esta arquitectura est√° dise√±ada para
        crecer de 50,000 usuarios iniciales hasta 10M+ usuarios sin necesidad de
        re-arquitectura, solo agregando m√°s nodos horizontalmente.
      </div>
    </div>

    <div class="footer">
      <p>Propuesta de Arquitectura - Sistema Bancario BP | Cap√≠tulo 2 de 17</p>
    </div>
    <script src="mermaid.min.js"></script>
    <script src="panzoom.min.js"></script>
    <script src="app.js"></script>
  </body>
</html>
