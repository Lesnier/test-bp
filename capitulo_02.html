<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CapÃ­tulo 2 - Arquitectura General del Sistema</title>
    <link rel="stylesheet" href="styles.css" />
    <style>
      .table-container {
        overflow-x: auto;
      }

      .table-container tbody tr:nth-of-type(1) {
        background-color: hsl(210, 80%, 95%);
      }
      .table-container tbody tr:nth-of-type(2) {
        background-color: hsl(210, 80%, 96%);
      }
      .table-container tbody tr:nth-of-type(3) {
        background-color: hsl(210, 80%, 97%);
      }
      .table-container tbody tr:nth-of-type(4) {
        background-color: hsl(210, 80%, 98%);
      }
      .table-container tbody tr:nth-of-type(5) {
        background-color: hsl(210, 80%, 98.5%);
      }
      .table-container tbody tr:nth-of-type(6) {
        background-color: hsl(210, 80%, 99%);
      }
      .table-container tbody tr:nth-of-type(7) {
        background-color: hsl(210, 80%, 99.5%);
      }

      .table-container tbody tr td:first-child {
        font-weight: 500;
        color: #0056b3;
      }

      code {
        background-color: #e9ecef;
        padding: 2px 5px;
        border-radius: 4px;
        font-family: "SF Mono", "Fira Code", monospace;
      }

      .ddd-highlight {
        padding: 20px;
        border-radius: 8px;
        margin: 20px 0;
      }

      .hexagonal-box {
        border: 3px solid #667eea;
        padding: 15px;
        margin: 15px 0;
        border-radius: 8px;
        background: #f8f9ff;
      }

      .architecture-layer {
        border-left: 4px solid #667eea;
        padding-left: 15px;
        margin: 10px 0;
      }
    </style>
  </head>
  <body>
    <div class="nav-header">
      <h2>CapÃ­tulo 2: Arquitectura General del Sistema</h2>
      <div class="nav-buttons">
        <a href="capitulo_01.html" class="nav-btn">â† Anterior</a>
        <a href="index.html" class="nav-btn">Ãndice</a>
        <a href="capitulo_03.html" class="nav-btn">Siguiente â†’</a>
      </div>
    </div>

    <h1>2. ARQUITECTURA GENERAL DEL SISTEMA</h1>

    <div class="ddd-highlight">
      <h2>ğŸ¯ Enfoque ArquitectÃ³nico: Domain-Driven Design (DDD)</h2>
      <p>
        Este sistema estÃ¡ fundamentado en los principios de
        <strong>Domain-Driven Design (DDD)</strong> combinado con
        <strong>Arquitectura Hexagonal (Puertos y Adaptadores)</strong>. Cada
        microservicio representa un <strong>Bounded Context</strong> del dominio
        bancario, con su propio modelo de dominio, lenguaje ubicuo y reglas de
        negocio encapsuladas.
      </p>
      <p>
        <strong>Principio fundamental:</strong> El dominio de negocio estÃ¡ en el
        centro, completamente aislado de detalles tÃ©cnicos de infraestructura
        mediante puertos y adaptadores.
      </p>
    </div>

    <h2>2.1 Vista de Contexto</h2>

    <div class="section">
      <p>
        El sistema bancario BP permite a los usuarios gestionar sus finanzas
        mediante aplicaciones web (SPA) y mÃ³vil, con las siguientes capacidades
        principales:
      </p>

      <ul>
        <li>
          <strong>Consulta de histÃ³rico de movimientos:</strong> Acceso a
          transacciones pasadas con filtros avanzados
        </li>
        <li>
          <strong>Transferencias intrabancarias:</strong> Pagos entre cuentas
          del mismo banco
        </li>
        <li>
          <strong>Transferencias interbancarias:</strong> Pagos a otros bancos
          con patrÃ³n SAGA
        </li>
        <li>
          <strong>Consulta de datos bÃ¡sicos:</strong> InformaciÃ³n del cliente y
          productos
        </li>
        <li>
          <strong>Notificaciones en tiempo real:</strong> VÃ­a GraphQL
          Subscriptions y Push/SMS
        </li>
        <li>
          <strong>AutenticaciÃ³n biomÃ©trica:</strong> Face ID, Touch ID y mÃ©todos
          tradicionales
        </li>
      </ul>
    </div>

    <h2>2.2 Contextos Delimitados (Bounded Contexts) - DDD</h2>

    <div class="section">
      <div class="hexagonal-box">
        <h3>ğŸ”· Â¿QuÃ© es un Bounded Context?</h3>
        <p>
          En DDD, un <strong>Bounded Context</strong> es una frontera explÃ­cita
          dentro de la cual un modelo de dominio especÃ­fico es vÃ¡lido. Cada
          contexto tiene su propio lenguaje ubicuo (Ubiquitous Language) y sus
          propias reglas de negocio.
        </p>
        <p>
          <strong
            >En nuestro sistema bancario, identificamos 3 Bounded Contexts
            principales:</strong
          >
        </p>
      </div>

      <table>
        <thead>
          <tr>
            <th>Bounded Context</th>
            <th>Responsabilidad de Dominio</th>
            <th>Entidades Principales</th>
            <th>Lenguaje Ubicuo</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Context: HistÃ³ricos</strong></td>
            <td>GestiÃ³n de consultas y reportes de transacciones histÃ³ricas</td>
            <td>Transaction, AccountStatement, MovementFilter</td>
            <td>Movimiento, Saldo, PerÃ­odo, Filtro</td>
          </tr>
          <tr>
            <td><strong>Context: Transferencias</strong></td>
            <td>
              EjecuciÃ³n de transferencias bancarias con consistencia
              transaccional
            </td>
            <td>Transfer, Account, TransferSaga, Compensation</td>
            <td>Transferencia, DÃ©bito, CrÃ©dito, CompensaciÃ³n</td>
          </tr>
          <tr>
            <td><strong>Context: AutenticaciÃ³n</strong></td>
            <td>Control de acceso, identidad y autorizaciÃ³n de usuarios</td>
            <td>User, Session, BiometricCredential, Token</td>
            <td>Usuario, SesiÃ³n, Credencial, AutenticaciÃ³n</td>
          </tr>
        </tbody>
      </table>

      <div class="note">
        <strong>Nota DDD:</strong> Cada Bounded Context se implementa como un
        microservicio independiente con su propia base de datos, garantizando la
        autonomÃ­a del dominio y evitando el acoplamiento de modelos.
      </div>
    </div>

    <h2>2.3 Arquitectura Hexagonal (Puertos y Adaptadores)</h2>

    <div class="section">
      <div class="hexagonal-box">
        <h3>â¬¡ Arquitectura Hexagonal en cada Microservicio</h3>
        <p>
          Cada Bounded Context (microservicio) sigue la
          <strong>Arquitectura Hexagonal</strong>, que separa el dominio de
          negocio de los detalles de infraestructura mediante:
        </p>
        <ul>
          <li>
            <strong>Dominio (Centro):</strong> Entidades, Value Objects,
            Agregados, Domain Services
          </li>
          <li>
            <strong>Puertos:</strong> Interfaces que definen cÃ³mo el dominio
            interactÃºa con el exterior
          </li>
          <li>
            <strong>Adaptadores:</strong> Implementaciones concretas de los
            puertos (GraphQL, REST, Kafka, Bases de Datos)
          </li>
        </ul>
      </div>

      <div class="architecture-layer">
        <h4>ğŸ”¹ Capa de Dominio (Core)</h4>
        <p>
          <strong>Responsabilidad:</strong> LÃ³gica de negocio pura,
          independiente de frameworks y tecnologÃ­a.
        </p>
        <p><strong>Componentes:</strong></p>
        <ul>
          <li>
            <strong>Entidades:</strong> Objetos con identidad Ãºnica (ej:
            Transfer, Account, User)
          </li>
          <li>
            <strong>Value Objects:</strong> Objetos inmutables sin identidad
            (ej: Money, AccountNumber, Email)
          </li>
          <li>
            <strong>Agregados:</strong> Conjuntos de entidades con un root (ej:
            TransferAggregate)
          </li>
          <li>
            <strong>Domain Events:</strong> Eventos que representan hechos del
            negocio (ej: TransferCompleted)
          </li>
          <li>
            <strong>Domain Services:</strong> LÃ³gica que no pertenece a una
            entidad especÃ­fica
          </li>
        </ul>
      </div>

      <div class="architecture-layer">
        <h4>ğŸ”¹ Puertos (Interfaces)</h4>
        <p>
          <strong>Responsabilidad:</strong> Contratos que definen cÃ³mo el
          dominio se comunica con el exterior.
        </p>
        <p><strong>Tipos de Puertos:</strong></p>
        <ul>
          <li>
            <strong>Puertos de Entrada (Driving/Primary):</strong> Casos de uso
            que el exterior invoca (ej: TransferUseCase)
          </li>
          <li>
            <strong>Puertos de Salida (Driven/Secondary):</strong> Interfaces
            que el dominio necesita (ej: TransferRepository, EventPublisher)
          </li>
        </ul>
      </div>

      <div class="architecture-layer">
        <h4>ğŸ”¹ Adaptadores</h4>
        <p>
          <strong>Responsabilidad:</strong> Implementaciones concretas de los
          puertos, conectando el dominio con tecnologÃ­as especÃ­ficas.
        </p>
        <p><strong>Tipos de Adaptadores:</strong></p>
        <ul>
          <li>
            <strong>Adaptadores de Entrada:</strong> GraphQL Resolvers, REST
            Controllers, Kafka Consumers
          </li>
          <li>
            <strong>Adaptadores de Salida:</strong> PostgreSQL Repository,
            MongoDB Repository, Kafka Producer, Redis Cache
          </li>
        </ul>
      </div>

      <div class="success">
        <strong>âœ“ Beneficios de Arquitectura Hexagonal:</strong>
        <ul>
          <li>Dominio completamente testeable sin dependencias externas</li>
          <li>Cambiar tecnologÃ­as (BD, API) sin tocar lÃ³gica de negocio</li>
          <li>Facilita testing con mocks de adaptadores</li>
          <li>Mantiene el foco en el dominio, no en la tecnologÃ­a</li>
        </ul>
      </div>
    </div>

    <h2>2.4 Diagrama de Contexto</h2>

    <div class="diagram">
      <div class="diagram-title">
        Arquitectura de Alto Nivel (Bounded Contexts + Hexagonal)
      </div>
      <pre class="mermaid">
flowchart TD
  Users["USUARIOS FINALES"]
  WebSPA["SPA&nbsp;Web&nbsp;(ReactJS)<br/>
            [Adaptador: UI]"]
  MobileApp["App&nbsp;MÃ³vil&nbsp;(React&nbsp;Native)<br/>
            [Adaptador: UI]"]
  WAF["WAF (Cloudflare/AWS) 
       - DDoS Protection
       - Bot Protection
       - OWASP Top 10"]
  Gateway["APOLLO GATEWAY<br/>
       .GraphQL Federation<br/>
       .Puerto&nbsp;de&nbsp;Entrada&nbsp;Principal<br/>"]
  
  subgraph BC1["ğŸ”· BOUNDED CONTEXT: HISTÃ“RICOS"]
    MS1["Microservicio&nbsp;HistÃ³ricos
          [Arquitectura Hexagonal]
          â€¢ Dominio: Transactions
          â€¢ Puertos: Queries
          â€¢ Adaptadores: GraphQL, MongoDB"]
  end
  
  subgraph BC2["ğŸ”· BOUNDED CONTEXT: TRANSFERENCIAS"]
    MS2["Microservicio&nbsp;Transferencias
    [Arquitectura Hexagonal]
    â€¢ Dominio: Transfers + SAGA
    â€¢ Puertos: Commands
    â€¢ Adaptadores: GraphQL, PostgreSQL, Kafka"]
  end
  
  subgraph BC3["ğŸ”· BOUNDED CONTEXT: AUTENTICACIÃ“N"]
    MS3["Microservicio&nbsp;AutenticaciÃ³n
    [Arquitectura Hexagonal]
    â€¢ Dominio: Identity
    â€¢ Puertos: AuthService
    â€¢ Adaptadores: REST, OAuth 2.0"]
  end
  
  Kafka["KAFKA MESSAGE BUS
          [Adaptador&nbsp;de&nbsp;ComunicaciÃ³n]
            Topics:&nbsp;SAGA,&nbsp;Domain&nbsp;Events,&nbsp;Logs"]

  Users --> WebSPA & MobileApp
  WebSPA & MobileApp -->|HTTPS/TLS 1.3| WAF
  WAF --> Gateway
  Gateway --> MS1 & MS2 & MS3
  MS1 & MS2 & MS3 --> Kafka

  classDef default fill:#f9f9f9,stroke:#333,stroke-width:2px;
  classDef gateway fill:#e1f3d8,stroke:#82c91e;
  classDef services fill:#d0ebff,stroke:#339af0;
  classDef messaging fill:#fff3bf,stroke:#f59f00;

  class WAF,Gateway gateway;
  class MS1,MS2,MS3 services;
  class Kafka messaging;
  </pre>
    </div>

    <h2>2.5 JustificaciÃ³n de Decisiones ArquitectÃ³nicas</h2>

    <div class="section">
      <div class="justification">
        <div class="justification-title">1. Domain-Driven Design (DDD)</div>
        <p>
          <strong>DecisiÃ³n:</strong> Adoptar DDD como filosofÃ­a de diseÃ±o
          principal
        </p>
        <p><strong>JustificaciÃ³n:</strong></p>
        <ul>
          <li>
            <strong>Complejidad del dominio bancario:</strong> DDD es ideal para
            dominios complejos con muchas reglas de negocio
          </li>
          <li>
            <strong>Lenguaje ubicuo:</strong> Desarrolladores y expertos del
            dominio hablan el mismo idioma
          </li>
          <li>
            <strong>Bounded Contexts:</strong> Permite dividir el sistema en
            partes manejables e independientes
          </li>
          <li>
            <strong>EvoluciÃ³n controlada:</strong> Cambios en un contexto no
            afectan otros
          </li>
          <li>
            <strong>Testing simplificado:</strong> Dominio puro sin dependencias
            externas
          </li>
        </ul>
      </div>

      <div class="justification">
        <div class="justification-title">
          2. Arquitectura Hexagonal (Puertos y Adaptadores)
        </div>
        <p>
          <strong>DecisiÃ³n:</strong> Implementar arquitectura hexagonal en cada
          microservicio
        </p>
        <p><strong>JustificaciÃ³n:</strong></p>
        <ul>
          <li>
            <strong>Independencia tecnolÃ³gica:</strong> Cambiar BD o API sin
            tocar dominio
          </li>
          <li>
            <strong>Testabilidad:</strong> Probar lÃ³gica de negocio sin
            infraestructura
          </li>
          <li>
            <strong>Mantenibilidad:</strong> Dominio aislado facilita cambios
          </li>
          <li>
            <strong>Flexibilidad:</strong> Agregar nuevos adaptadores sin
            modificar dominio
          </li>
          <li>
            <strong>Claridad:</strong> SeparaciÃ³n explÃ­cita de responsabilidades
          </li>
        </ul>
      </div>

      <div class="justification">
        <div class="justification-title">3. WAF (Web Application Firewall)</div>
        <p>
          <strong>DecisiÃ³n:</strong> Cloudflare WAF o AWS WAF como primera lÃ­nea
          de defensa
        </p>
        <p><strong>JustificaciÃ³n:</strong></p>
        <ul>
          <li>
            ProtecciÃ³n contra ataques OWASP Top 10 (SQL Injection, XSS, CSRF)
          </li>
          <li>MitigaciÃ³n de DDoS antes de que llegue a la infraestructura</li>
          <li>DetecciÃ³n y bloqueo de bots maliciosos</li>
          <li>ReducciÃ³n de costos al filtrar trÃ¡fico malicioso temprano</li>
          <li>Cumplimiento de PCI DSS Requirement 6.6</li>
        </ul>
      </div>

      <div class="justification">
        <div class="justification-title">
          4. Apollo Gateway con GraphQL Federation
        </div>
        <p>
          <strong>DecisiÃ³n:</strong> Punto Ãºnico de entrada con GraphQL como
          protocolo principal (95%)
        </p>
        <p><strong>JustificaciÃ³n:</strong></p>
        <ul>
          <li>
            <strong>Eficiencia:</strong> ReducciÃ³n de 60-70% en latencia vs
            mÃºltiples requests REST
          </li>
          <li>
            <strong>Simplicidad:</strong> Un solo endpoint para todas las
            queries y mutations
          </li>
          <li>
            <strong>Seguridad centralizada:</strong> JWT validation, rate
            limiting en un solo lugar
          </li>
          <li>
            <strong>Query complexity analysis:</strong> Previene queries
            abusivas
          </li>
          <li>
            <strong>Escalabilidad:</strong> Facilita agregar nuevos
            microservicios sin cambiar frontend
          </li>
          <li>
            <strong>Mejor UX:</strong> ReducciÃ³n de 65-70% en bandwidth
            consumido (crÃ­tico para mobile)
          </li>
        </ul>
      </div>

      <div class="justification">
        <div class="justification-title">
          5. Microservicios por Bounded Context
        </div>
        <p>
          <strong>DecisiÃ³n:</strong> Cada Bounded Context es un microservicio
          independiente
        </p>
        <p><strong>JustificaciÃ³n:</strong></p>
        <ul>
          <li>
            <strong>AlineaciÃ³n DDD:</strong> Un microservicio = Un Bounded
            Context
          </li>
          <li>
            <strong>Escalabilidad independiente:</strong> Cada servicio escala
            segÃºn su carga especÃ­fica
          </li>
          <li>
            <strong>Despliegues independientes:</strong> Actualizar un servicio
            sin afectar los demÃ¡s
          </li>
          <li>
            <strong>Resiliencia:</strong> Fallo de un servicio no tumba todo el
            sistema (bulkhead pattern)
          </li>
          <li>
            <strong>TecnologÃ­a especÃ­fica:</strong> Elegir la mejor herramienta
            para cada problema
          </li>
          <li>
            <strong>Equipos autÃ³nomos:</strong> Cada equipo trabaja en su
            contexto
          </li>
        </ul>
      </div>
    </div>

    <h2>2.6 Componentes Principales del Sistema</h2>

    <div class="section">
      <table>
        <thead>
          <tr>
            <th>Componente</th>
            <th>TecnologÃ­a</th>
            <th>PropÃ³sito</th>
            <th>JustificaciÃ³n</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Frontend Web</strong></td>
            <td>React 18+ SPA</td>
            <td>Interfaz de usuario web</td>
            <td>Ecosistema maduro, reutilizaciÃ³n de componentes con mÃ³vil</td>
          </tr>
          <tr>
            <td><strong>Frontend MÃ³vil</strong></td>
            <td>React Native 0.73+</td>
            <td>Apps iOS/Android</td>
            <td>Compartir cÃ³digo con web, menor time-to-market</td>
          </tr>
          <tr>
            <td><strong>API Gateway</strong></td>
            <td>Apollo Gateway</td>
            <td>Punto de entrada Ãºnico</td>
            <td>GraphQL Federation, mejor que REST tradicional</td>
          </tr>
          <tr>
            <td><strong>Microservicios</strong></td>
            <td>Node.js + GraphQL</td>
            <td>LÃ³gica de negocio (Dominio DDD)</td>
            <td>Worker Threads para paralelismo, GraphQL eficiente</td>
          </tr>
          <tr>
            <td><strong>Message Bus</strong></td>
            <td>Apache Kafka</td>
            <td>ComunicaciÃ³n asÃ­ncrona entre contexts</td>
            <td>
              Alta throughput, durabilidad, ideal para SAGA y Domain Events
            </td>
          </tr>
          <tr>
            <td><strong>Orquestador</strong></td>
            <td>Kubernetes</td>
            <td>GestiÃ³n de contenedores</td>
            <td>Autoescalado, self-healing, standard de industria</td>
          </tr>
          <tr>
            <td><strong>Bases de Datos</strong></td>
            <td>PostgreSQL + MongoDB</td>
            <td>Persistencia (Database per Service)</td>
            <td>CQRS: PostgreSQL para escritura, MongoDB para lectura</td>
          </tr>
          <tr>
            <td><strong>CachÃ©</strong></td>
            <td>Redis</td>
            <td>CachÃ© + Sesiones + SAGA State</td>
            <td>Performance, estado temporal de SAGAs</td>
          </tr>
          <tr>
            <td><strong>Observabilidad</strong></td>
            <td>ELK + Prometheus</td>
            <td>Logs + MÃ©tricas</td>
            <td>Stack estÃ¡ndar, integraciÃ³n con K8s</td>
          </tr>
        </tbody>
      </table>
    </div>

    <h2>2.7 Flujo de Datos Principal</h2>

    <div class="section">
      <div class="diagram">
        <div class="diagram-title">
          Flujo de Request TÃ­pico (Arquitectura Hexagonal)
        </div>
        <pre class="mermaid">
sequenceDiagram
  actor U as Usuario (App)
  participant A as Adaptador UI
  participant W as WAF
  participant AG as Apollo Gateway (Puerto)
  participant GR as GraphQL Resolver (Adaptador Entrada)
  participant UC as Use Case (Puerto Entrada)
  participant DS as Domain Service (Dominio)
  participant RP as Repository Port (Puerto Salida)
  participant DB as DB Adapter (Adaptador Salida)
  participant Cache as Redis Cache

  U->>A: Solicita movimientos
  A->>W: GraphQL Query (HTTPS)
  Note over W: Valida seguridad
  
  W->>AG: âœ“ Request limpia
  Note over AG: Puerto de entrada principal<br/>Valida JWT
  
  AG->>GR: Enruta query
  Note over GR: Adaptador de entrada GraphQL
  
  GR->>UC: Ejecuta caso de uso
  Note over UC: Puerto de entrada<br/>GetAccountMovements
  
  UC->>DS: Aplica lÃ³gica dominio
  Note over DS: DOMINIO PURO<br/>Reglas de negocio
  
  DS->>RP: Solicita datos
  Note over RP: Puerto de salida<br/>TransactionRepository interface
  
  RP->>Cache: Intenta cache
  Cache-->>RP: Cache miss
  
  RP->>DB: Query BD
  Note over DB: Adaptador MongoDB<br/>Implementa Repository Port
  
  DB-->>RP: Retorna datos
  RP-->>DS: Entities de dominio
  DS-->>UC: Datos procesados
  UC-->>GR: DTO de salida
  GR-->>AG: GraphQL response
  AG-->>W: Datos optimizados
  W-->>A: 4 KB vs 11 KB REST
  A-->>U: Renderiza UI
  Note over U: 120ms vs 350ms latencia
    </pre>
      </div>

      <div class="note">
        <strong>Nota ArquitectÃ³nica:</strong> Observa cÃ³mo el flujo pasa por
        capas bien definidas:
        <ul>
          <li>
            <strong>Adaptadores de Entrada:</strong> GraphQL Resolver recibe el
            request
          </li>
          <li>
            <strong>Puerto de Entrada:</strong> Use Case define el contrato
          </li>
          <li>
            <strong>Dominio:</strong> LÃ³gica de negocio pura, sin dependencias
            externas
          </li>
          <li><strong>Puerto de Salida:</strong> Interface Repository</li>
          <li>
            <strong>Adaptador de Salida:</strong> ImplementaciÃ³n concreta
            (MongoDB, Redis)
          </li>
        </ul>
      </div>
    </div>

    <h2>2.8 Principios ArquitectÃ³nicos</h2>

    <div class="section">
      <h3>2.8.1 Principios Fundamentales DDD</h3>

      <ol>
        <li>
          <strong>Ubiquitous Language (Lenguaje Ubicuo):</strong>
          <p>
            El cÃ³digo usa exactamente los mismos tÃ©rminos que los expertos del
            dominio. No hay traducciÃ³n entre negocio y tÃ©cnico: "Transfer",
            "Account", "Compensation" son nombres tanto en el cÃ³digo como en las
            conversaciones de negocio.
          </p>
        </li>

        <li>
          <strong>Bounded Contexts Independientes:</strong>
          <p>
            Cada contexto (HistÃ³ricos, Transferencias, AutenticaciÃ³n) tiene su
            propio modelo y no comparte entidades con otros contextos. La
            comunicaciÃ³n es via Domain Events.
          </p>
        </li>

        <li>
          <strong>Domain at the Core (Dominio en el Centro):</strong>
          <p>
            La lÃ³gica de negocio estÃ¡ completamente aislada de frameworks, bases
            de datos, y APIs. El dominio no conoce GraphQL, ni PostgreSQL, ni
            Kafka.
          </p>
        </li>

        <li>
          <strong>Agregados con RaÃ­z:</strong>
          <p>
            Conjuntos de entidades relacionadas se agrupan en Agregados con una
            raÃ­z que garantiza la consistencia. Ejemplo: TransferAggregate
            controla Transfer + TransferLine.
          </p>
        </li>

        <li>
          <strong>Domain Events:</strong>
          <p>
            Los hechos importantes del dominio se modelan como eventos:
            TransferCompleted, AccountDebited, CompensationTriggered. Facilitan
            comunicaciÃ³n entre contextos.
          </p>
        </li>
      </ol>

      <h3>2.8.2 Principios de Arquitectura Hexagonal</h3>

      <ol>
        <li>
          <strong>Dependency Inversion:</strong>
          <p>
            El dominio define interfaces (puertos), y la infraestructura las
            implementa (adaptadores). Nunca al revÃ©s. El dominio no depende de
            nadie.
          </p>
        </li>

        <li>
          <strong>Ports and Adapters:</strong>
          <p>
            Toda comunicaciÃ³n con el exterior se hace mediante puertos
            (interfaces) y adaptadores (implementaciones). Podemos cambiar de
            GraphQL a gRPC sin tocar el dominio.
          </p>
        </li>

        <li>
          <strong>Testabilidad Total:</strong>
          <p>
            El dominio se testea con mocks de puertos, sin necesidad de levantar
            bases de datos o servidores. Tests rÃ¡pidos y confiables.
          </p>
        </li>
      </ol>

      <h3>2.8.3 Otros Principios ArquitectÃ³nicos</h3>

      <ol>
        <li>
          <strong>API First con GraphQL:</strong>
          <p>
            DiseÃ±ar APIs antes de implementar, con GraphQL como protocolo
            principal para mÃ¡xima eficiencia.
          </p>
        </li>

        <li>
          <strong>Idempotencia:</strong>
          <p>
            Todas las operaciones crÃ­ticas son idempotentes (pueden ejecutarse
            mÃºltiples veces sin efectos adversos).
          </p>
        </li>

        <li>
          <strong>Observabilidad desde el DiseÃ±o:</strong>
          <p>
            Logs estructurados, mÃ©tricas y traces implementados desde el primer
            dÃ­a.
          </p>
        </li>

        <li>
          <strong>Security by Design:</strong>
          <p>Seguridad integrada en cada capa, no agregada despuÃ©s.</p>
        </li>

        <li>
          <strong>Fail Fast, Recover Faster:</strong>
          <p>Detectar fallos rÃ¡pidamente y recuperarse automÃ¡ticamente.</p>
        </li>
      </ol>

      <h3>2.8.4 Patrones ArquitectÃ³nicos Utilizados</h3>

      <table>
        <thead>
          <tr>
            <th>PatrÃ³n</th>
            <th>AplicaciÃ³n</th>
            <th>Beneficio</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Bounded Context</strong></td>
            <td>DivisiÃ³n del sistema en contextos</td>
            <td>Modelos de dominio independientes y mantenibles</td>
          </tr>
          <tr>
            <td><strong>Hexagonal Architecture</strong></td>
            <td>Estructura interna de microservicios</td>
            <td>Dominio aislado de tecnologÃ­a</td>
          </tr>
          <tr>
            <td><strong>CQRS</strong></td>
            <td>SeparaciÃ³n lectura/escritura</td>
            <td>OptimizaciÃ³n de performance en consultas</td>
          </tr>
          <tr>
            <td><strong>SAGA</strong></td>
            <td>Transacciones distribuidas</td>
            <td>Consistencia eventual con compensaciÃ³n</td>
          </tr>
          <tr>
            <td><strong>Event Sourcing</strong></td>
            <td>AuditorÃ­a y sincronizaciÃ³n</td>
            <td>Trazabilidad completa, replay de eventos</td>
          </tr>
          <tr>
            <td><strong>Domain Events</strong></td>
            <td>ComunicaciÃ³n entre Bounded Contexts</td>
            <td>Desacoplamiento total entre contextos</td>
          </tr>
          <tr>
            <td><strong>Circuit Breaker</strong></td>
            <td>Llamadas entre servicios</td>
            <td>Previene cascading failures</td>
          </tr>
          <tr>
            <td><strong>Bulkhead</strong></td>
            <td>Aislamiento de recursos</td>
            <td>Fallo de un tipo de operaciÃ³n no afecta otros</td>
          </tr>
          <tr>
            <td><strong>API Gateway</strong></td>
            <td>Punto de entrada Ãºnico</td>
            <td>Seguridad centralizada, routing inteligente</td>
          </tr>
          <tr>
            <td><strong>Database per Service</strong></td>
            <td>Cada microservicio su BD</td>
            <td>Independencia total, escalabilidad</td>
          </tr>
        </tbody>
      </table>
    </div>

    <h2>2.9 Capas de la Arquitectura (VisiÃ³n Macro)</h2>

    <div class="section">
      <div class="table-container">
        <table>
          <thead>
            <tr>
              <th>Capa</th>
              <th>Responsabilidad Principal</th>
              <th>TecnologÃ­as Clave</th>
              <th>Flujo / Interacciones</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><b>Capa 1: PresentaciÃ³n</b> ğŸ–¼ï¸</td>
              <td>
                Interfaz con la que interactÃºa el usuario final (Cliente
                Web/MÃ³vil). <strong>[Adaptador de UI]</strong>
              </td>
              <td>
                <code>React</code>, <code>React Native</code>,
                <code>Apollo Client</code>
              </td>
              <td>EnvÃ­a peticiones del usuario hacia el API Gateway.</td>
            </tr>
            <tr>
              <td><b>Capa 2: API Gateway</b> ğŸšª</td>
              <td>
                Punto de entrada Ãºnico que gestiona la seguridad y el
                enrutamiento. <strong>[Puerto Principal]</strong>
              </td>
              <td>
                <code>Apollo Gateway</code>, <code>Kong</code>,
                <code>NGINX</code>
              </td>
              <td>
                Recibe peticiones de la Capa 1 y las dirige a los servicios
                correspondientes.
              </td>
            </tr>
            <tr>
              <td><b>Capa 3: Bounded Contexts</b> ğŸ§ </td>
              <td>
                Microservicios con arquitectura hexagonal. Contienen dominio +
                puertos + adaptadores. <strong>[Microservicios DDD]</strong>
              </td>
              <td><code>Microservicios en Node.js</code></td>
              <td>
                Recibe peticiones del API Gateway y utiliza las capas de
                MensajerÃ­a y Persistencia.
              </td>
            </tr>
            <tr>
              <td><b>Capa 4: MensajerÃ­a</b> ğŸ“¨</td>
              <td>
                Gestiona comunicaciÃ³n asÃ­ncrona y Domain Events entre Bounded
                Contexts.
                <strong>[Adaptador de ComunicaciÃ³n]</strong>
              </td>
              <td><code>Apache Kafka</code></td>
              <td>
                Es utilizada por los Bounded Contexts para publicar/consumir
                Domain Events.
              </td>
            </tr>
            <tr>
              <td><b>Capa 5: Persistencia</b> ğŸ’¾</td>
              <td>
                Almacenamiento y recuperaciÃ³n de datos. Cada contexto tiene su
                propia BD.
                <strong>[Adaptadores de BD]</strong>
              </td>
              <td><code>PostgreSQL, MongoDB, Redis</code></td>
              <td>
                Provee los datos que los Domain Services necesitan para operar.
              </td>
            </tr>
            <tr>
              <td><b>Capa 6: Infraestructura</b> ğŸ—ï¸</td>
              <td>
                Orquesta y ejecuta todos los servicios del backend en
                contenedores.
              </td>
              <td><code>Kubernetes</code>, <code>Docker</code></td>
              <td>
                Es la base sobre la que se despliegan y operan las capas 3, 4 y
                5.
              </td>
            </tr>
            <tr>
              <td><b>Capa Transversal: Observabilidad</b> ğŸ“Š</td>
              <td>Monitorea la salud y el rendimiento de todo el sistema.</td>
              <td>
                <code>Prometheus</code>, <code>Grafana</code>,
                <code>ELK Stack</code>
              </td>
              <td>
                Recopila mÃ©tricas y logs de todas las demÃ¡s capas para anÃ¡lisis
                y alertas.
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

    <h2>2.10 Estructura de un Microservicio (Ejemplo: Transferencias)</h2>

    <div class="section">
      <div class="hexagonal-box">
        <h3>â¬¡ AnatomÃ­a de un Bounded Context con Arquitectura Hexagonal</h3>
        <p>
          Cada microservicio sigue esta estructura de carpetas que refleja las
          capas hexagonales:
        </p>
      </div>

      <div class="code-section">
        <pre><code>ms-transferencias/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ domain/                    # ğŸŸ¦ CAPA DE DOMINIO (Centro del HexÃ¡gono)
â”‚   â”‚   â”œâ”€â”€ entities/              # Entidades con identidad
â”‚   â”‚   â”‚   â”œâ”€â”€ Transfer.ts        # Entidad Transfer
â”‚   â”‚   â”‚   â”œâ”€â”€ Account.ts         # Entidad Account
â”‚   â”‚   â”‚   â””â”€â”€ TransferLine.ts
â”‚   â”‚   â”œâ”€â”€ value-objects/         # Objetos de valor inmutables
â”‚   â”‚   â”‚   â”œâ”€â”€ Money.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ AccountNumber.ts
â”‚   â”‚   â”‚   â””â”€â”€ TransferId.ts
â”‚   â”‚   â”œâ”€â”€ aggregates/            # RaÃ­ces de agregado
â”‚   â”‚   â”‚   â””â”€â”€ TransferAggregate.ts
â”‚   â”‚   â”œâ”€â”€ events/                # Domain Events
â”‚   â”‚   â”‚   â”œâ”€â”€ TransferCreated.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ TransferCompleted.ts
â”‚   â”‚   â”‚   â””â”€â”€ CompensationTriggered.ts
â”‚   â”‚   â”œâ”€â”€ services/              # Domain Services
â”‚   â”‚   â”‚   â”œâ”€â”€ TransferValidator.ts
â”‚   â”‚   â”‚   â””â”€â”€ CompensationService.ts
â”‚   â”‚   â””â”€â”€ exceptions/            # Excepciones de dominio
â”‚   â”‚       â””â”€â”€ InsufficientFundsError.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ application/               # ğŸŸ© PUERTOS (Casos de Uso)
â”‚   â”‚   â”œâ”€â”€ ports/
â”‚   â”‚   â”‚   â”œâ”€â”€ in/               # Puertos de Entrada (Driving)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ CreateTransferUseCase.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ CancelTransferUseCase.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ GetTransferStatusUseCase.ts
â”‚   â”‚   â”‚   â””â”€â”€ out/              # Puertos de Salida (Driven)
â”‚   â”‚   â”‚       â”œâ”€â”€ TransferRepository.ts      # Interface
â”‚   â”‚   â”‚       â”œâ”€â”€ AccountRepository.ts       # Interface
â”‚   â”‚   â”‚       â”œâ”€â”€ EventPublisher.ts          # Interface
â”‚   â”‚   â”‚       â””â”€â”€ SagaStateRepository.ts     # Interface
â”‚   â”‚   â”œâ”€â”€ dto/                  # ğŸ“¦ DTOs (Data Transfer Objects)
â”‚   â”‚   â”‚   â”œâ”€â”€ CreateTransferDto.ts          # Input DTO
â”‚   â”‚   â”‚   â”œâ”€â”€ TransferResponseDto.ts        # Output DTO
â”‚   â”‚   â”‚   â”œâ”€â”€ CancelTransferDto.ts
â”‚   â”‚   â”‚   â””â”€â”€ TransferStatusDto.ts
â”‚   â”‚   â”œâ”€â”€ mappers/              # Mappers: DTO â†” Domain Entity
â”‚   â”‚   â”‚   â”œâ”€â”€ TransferMapper.ts
â”‚   â”‚   â”‚   â””â”€â”€ AccountMapper.ts
â”‚   â”‚   â””â”€â”€ usecases/             # ImplementaciÃ³n de casos de uso
â”‚   â”‚       â”œâ”€â”€ CreateTransferUseCaseImpl.ts
â”‚   â”‚       â””â”€â”€ CancelTransferUseCaseImpl.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ infrastructure/            # ğŸŸ¨ ADAPTADORES
â”‚   â”‚   â”œâ”€â”€ adapters/
â”‚   â”‚   â”‚   â”œâ”€â”€ in/               # Adaptadores de Entrada
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ graphql/
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ TransferResolver.ts
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ schema.graphql
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ kafka/
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ TransferEventConsumer.ts
â”‚   â”‚   â”‚   â””â”€â”€ out/              # Adaptadores de Salida
â”‚   â”‚   â”‚       â”œâ”€â”€ postgres/
â”‚   â”‚   â”‚       â”‚   â””â”€â”€ PostgresTransferRepository.ts
â”‚   â”‚   â”‚       â”œâ”€â”€ kafka/
â”‚   â”‚   â”‚       â”‚   â””â”€â”€ KafkaEventPublisher.ts
â”‚   â”‚   â”‚       â””â”€â”€ redis/
â”‚   â”‚   â”‚           â””â”€â”€ RedisSagaStateRepository.ts
â”‚   â”‚   â”œâ”€â”€ config/               # ConfiguraciÃ³n
â”‚   â”‚   â”‚   â”œâ”€â”€ database.ts
â”‚   â”‚   â”‚   â””â”€â”€ kafka.ts
â”‚   â”‚   â””â”€â”€ migrations/           # Migraciones de BD
â”‚   â”‚
â”‚   â””â”€â”€ shared/                   # CÃ³digo compartido
â”‚       â”œâ”€â”€ utils/
â”‚       â””â”€â”€ types/
â”‚
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ unit/                     # Tests del dominio (puros)
â”‚   â”œâ”€â”€ integration/              # Tests de adaptadores
â”‚   â””â”€â”€ e2e/                      # Tests end-to-end
â”‚
â””â”€â”€ package.json</code></pre>
      </div>

      <div class="note">
        <strong>ğŸ“¦ Sobre los DTOs (Data Transfer Objects):</strong>
        <p>
          Los DTOs son objetos simples que transfieren datos entre capas. Son
          cruciales en arquitectura hexagonal porque:
        </p>
        <ul>
          <li>
            <strong>Desacoplan el dominio de las APIs:</strong> El dominio no
            conoce GraphQL, REST o Kafka
          </li>
          <li>
            <strong>Control de datos expuestos:</strong> Solo se expone lo que
            el API necesita, no toda la entidad
          </li>
          <li>
            <strong>ValidaciÃ³n en el borde:</strong> Los DTOs validan datos
            antes de llegar al dominio
          </li>
          <li>
            <strong>Versionado independiente:</strong> Cambiar API sin cambiar
            dominio
          </li>
        </ul>
        <p>
          <strong>Flujo tÃ­pico:</strong>
          GraphQL Request â†’ DTO â†’ Mapper â†’ Domain Entity â†’ Use Case â†’ Domain
          Entity â†’ Mapper â†’ DTO â†’ GraphQL Response
        </p>

        <p><strong>Ejemplo prÃ¡ctico:</strong></p>
        <pre
          style="
            background: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
          "
        ><code>// 1. GraphQL Resolver recibe el request (Adaptador de Entrada)
async createTransfer(args: CreateTransferInput) {
  // 2. Convierte input a DTO
  const dto = new CreateTransferDto(args);
  
  // 3. Mapper convierte DTO â†’ Domain Entity
  const transfer = TransferMapper.toDomain(dto);
  
  // 4. Ejecuta caso de uso con entidad de dominio
  const result = await createTransferUseCase.execute(transfer);
  
  // 5. Mapper convierte Domain Entity â†’ DTO de respuesta
  const responseDto = TransferMapper.toDto(result);
  
  // 6. Retorna DTO al cliente
  return responseDto;
}</code></pre>
      </div>

      <div class="success">
        <strong>âœ“ Ventajas de esta estructura:</strong>
        <ul>
          <li>
            <strong>Claridad:</strong> Es evidente quÃ© es dominio, quÃ© son
            puertos y quÃ© son adaptadores
          </li>
          <li>
            <strong>Testabilidad:</strong> El dominio se testea sin dependencias
            externas
          </li>
          <li>
            <strong>Mantenibilidad:</strong> Cambios en infraestructura no
            afectan dominio
          </li>
          <li>
            <strong>Onboarding:</strong> Nuevos desarrolladores entienden la
            estructura rÃ¡pidamente
          </li>
        </ul>
      </div>
    </div>

    <h2>2.11 Consideraciones de DiseÃ±o</h2>

    <div class="section">
      <div class="success">
        <strong>âœ“ Decisiones Clave Validadas:</strong>
        <ul>
          <li>
            <strong>DDD + Hexagonal:</strong> Dominio en el centro, tecnologÃ­a
            en la periferia
          </li>
          <li>
            <strong>Bounded Contexts independientes:</strong> Cada contexto
            evoluciona sin afectar otros
          </li>
          <li>
            <strong>GraphQL como protocolo principal</strong> reduce latencia
            60-70%
          </li>
          <li>
            <strong>Kafka para Domain Events</strong> permite comunicaciÃ³n
            asÃ­ncrona entre contextos
          </li>
          <li>
            <strong>CQRS optimiza lecturas</strong> sin impactar escrituras
          </li>
          <li>
            <strong>PatrÃ³n SAGA</strong> permite transacciones distribuidas con
            compensaciÃ³n
          </li>
          <li>
            <strong>Database per Service</strong> garantiza independencia total
            de cada contexto
          </li>
        </ul>
      </div>

      <div class="note">
        <strong>Nota Importante sobre DDD:</strong> Esta arquitectura no es solo
        sobre tecnologÃ­a, es sobre modelar el dominio de negocio correctamente.
        El cÃ³digo refleja exactamente cÃ³mo funciona el negocio bancario, usando
        el mismo lenguaje que los expertos del dominio. Los cambios en el
        negocio se traducen directamente a cambios en el cÃ³digo del dominio, sin
        necesidad de tocar infraestructura.
      </div>

      <div class="note">
        <strong>Escalabilidad:</strong> Esta arquitectura estÃ¡ diseÃ±ada para
        crecer de 50,000 usuarios iniciales hasta 10M+ usuarios sin necesidad de
        re-arquitectura, solo agregando mÃ¡s nodos horizontalmente.
      </div>
    </div>

    <div class="footer">
      <p>Propuesta de Arquitectura - Sistema Bancario BP | CapÃ­tulo 2 de 17</p>
    </div>
    <script src="mermaid.min.js"></script>
    <script src="panzoom.min.js"></script>
    <script src="app.js"></script>
  </body>
</html>
