<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Capítulo 2 - Arquitectura General del Sistema</title>
    <link rel="stylesheet" href="styles.css" />
    <style>
      /* Contenedor para la tabla */
      .table-container {
        overflow-x: auto;
      }

      /* ---- EFECTO DEGRADADO EN FILAS ---- */
      .table-container tbody tr:nth-of-type(1) {
        background-color: hsl(210, 80%, 95%);
      }
      .table-container tbody tr:nth-of-type(2) {
        background-color: hsl(210, 80%, 96%);
      }
      .table-container tbody tr:nth-of-type(3) {
        background-color: hsl(210, 80%, 97%);
      }
      .table-container tbody tr:nth-of-type(4) {
        background-color: hsl(210, 80%, 98%);
      }
      .table-container tbody tr:nth-of-type(5) {
        background-color: hsl(210, 80%, 98.5%);
      }
      .table-container tbody tr:nth-of-type(6) {
        background-color: hsl(210, 80%, 99%);
      }
      .table-container tbody tr:nth-of-type(7) {
        background-color: hsl(210, 80%, 99.5%);
      }

      .table-container tbody tr td:first-child {
        font-weight: 500;
        color: #0056b3;
      }
      code {
        background-color: #e9ecef;
        padding: 2px 5px;
        border-radius: 4px;
        font-family: "SF Mono", "Fira Code", monospace;
      }
    </style>
  </head>
  <body>
    <div class="nav-header">
      <h2>Capítulo 2: Arquitectura General del Sistema</h2>
      <div class="nav-buttons">
        <a href="capitulo_01.html" class="nav-btn">← Anterior</a>
        <a href="index.html" class="nav-btn">Índice</a>
        <a href="capitulo_03.html" class="nav-btn">Siguiente →</a>
      </div>
    </div>

    <h1>2. ARQUITECTURA GENERAL DEL SISTEMA</h1>

    <h2>2.1 Vista de Contexto</h2>

    <div class="section">
      <p>
        El sistema bancario BP permite a los usuarios gestionar sus finanzas
        mediante aplicaciones web (SPA) y móvil, con las siguientes capacidades
        principales:
      </p>

      <ul>
        <li>
          <strong>Consulta de histórico de movimientos:</strong> Acceso a
          transacciones pasadas con filtros avanzados
        </li>
        <li>
          <strong>Transferencias intrabancarias:</strong> Pagos entre cuentas
          del mismo banco
        </li>
        <li>
          <strong>Transferencias interbancarias:</strong> Pagos a otros bancos
          con patrón SAGA
        </li>
        <li>
          <strong>Consulta de datos básicos:</strong> Información del cliente y
          productos
        </li>
        <li>
          <strong>Notificaciones en tiempo real:</strong> Vía GraphQL
          Subscriptions y Push/SMS
        </li>
        <li>
          <strong>Autenticación biométrica:</strong> Face ID, Touch ID y métodos
          tradicionales
        </li>
      </ul>
    </div>

    <h2>2.2 Diagrama de Contexto</h2>

    <div class="diagram">
      <div class="diagram-title">Arquitectura de Alto Nivel</div>
      <pre class="mermaid">

flowchart TD
  Users["USUARIOS FINALES"]
  WebSPA["SPA Web\n(ReactJS)"]
  MobileApp["App Móvil\n(React Native)"]
  WAF["WAF (Cloudflare/AWS)\n- DDoS Protection\n- Bot Protection\n- OWASP Top 10"]
  Gateway["APOLLO GATEWAY\n(GraphQL Federation)\n- Rate Limiting\n- JWT Validation\n- Query Complexity"]
  MS1["Microservicio\nHistóricos\n(GraphQL + Workers)"]
  MS2["Microservicio\nTransferencias\n(GraphQL + SAGA)"]
  MS3["Microservicio\nAutenticación\n(REST + OAuth 2.0)"]
  Kafka["KAFKA MESSAGE BUS\n+ ZooKeeper Cluster\nTopics: SAGA, Events, Logs"]

  Users --> WebSPA & MobileApp
  WebSPA & MobileApp -->|HTTPS/TLS 1.3| WAF
  WAF --> Gateway
  Gateway --> MS1 & MS2 & MS3
  MS1 & MS2 & MS3 --> Kafka

  classDef default fill:#f9f9f9,stroke:#333,stroke-width:2px;
  classDef gateway fill:#e1f3d8,stroke:#82c91e;
  classDef services fill:#d0ebff,stroke:#339af0;
  classDef messaging fill:#fff3bf,stroke:#f59f00;

  class WAF,Gateway gateway;
  class MS1,MS2,MS3 services;
  class Kafka messaging;
    </pre
      >
    </div>

    <h2>2.3 Justificación de Decisiones Arquitectónicas</h2>

    <div class="section">
      <div class="justification">
        <div class="justification-title">1. WAF (Web Application Firewall)</div>
        <p>
          <strong>Decisión:</strong> Cloudflare WAF o AWS WAF como primera línea
          de defensa
        </p>
        <p><strong>Justificación:</strong></p>
        <ul>
          <li>
            Protección contra ataques OWASP Top 10 (SQL Injection, XSS, CSRF)
          </li>
          <li>Mitigación de DDoS antes de que llegue a la infraestructura</li>
          <li>Detección y bloqueo de bots maliciosos</li>
          <li>Reducción de costos al filtrar tráfico malicioso temprano</li>
          <li>Cumplimiento de PCI DSS Requirement 6.6</li>
        </ul>
      </div>

      <div class="justification">
        <div class="justification-title">
          2. Apollo Gateway con GraphQL Federation
        </div>
        <p>
          <strong>Decisión:</strong> Punto único de entrada con GraphQL como
          protocolo principal (95%)
        </p>
        <p><strong>Justificación:</strong></p>
        <ul>
          <li>
            <strong>Eficiencia:</strong> Reducción de 60-70% en latencia vs
            múltiples requests REST
          </li>
          <li>
            <strong>Simplicidad:</strong> Un solo endpoint para todas las
            queries y mutations
          </li>
          <li>
            <strong>Seguridad centralizada:</strong> JWT validation, rate
            limiting en un solo lugar
          </li>
          <li>
            <strong>Query complexity analysis:</strong> Previene queries
            abusivas
          </li>
          <li>
            <strong>Escalabilidad:</strong> Facilita agregar nuevos
            microservicios sin cambiar frontend
          </li>
          <li>
            <strong>Mejor UX:</strong> Reducción de 65-70% en bandwidth
            consumido (crítico para mobile)
          </li>
        </ul>
      </div>

      <div class="justification">
        <div class="justification-title">3. Arquitectura de Microservicios</div>
        <p>
          <strong>Decisión:</strong> Separación en servicios independientes por
          dominio de negocio
        </p>
        <p><strong>Justificación:</strong></p>
        <ul>
          <li>
            <strong>Escalabilidad independiente:</strong> Cada servicio escala
            según su carga específica
          </li>
          <li>
            <strong>Despliegues independientes:</strong> Actualizar un servicio
            sin afectar los demás
          </li>
          <li>
            <strong>Resiliencia:</strong> Fallo de un servicio no tumba todo el
            sistema (bulkhead pattern)
          </li>
          <li>
            <strong>Tecnología específica:</strong> Elegir la mejor herramienta
            para cada problema
          </li>
          <li>
            <strong>Equipos autónomos:</strong> Cada equipo puede trabajar
            independientemente
          </li>
          <li>
            <strong>Facilita testing:</strong> Tests unitarios e integración más
            simples
          </li>
        </ul>
      </div>
    </div>

    <h2>2.4 Componentes Principales del Sistema</h2>

    <div class="section">
      <table>
        <thead>
          <tr>
            <th>Componente</th>
            <th>Tecnología</th>
            <th>Propósito</th>
            <th>Justificación</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Frontend Web</strong></td>
            <td>React 18+ SPA</td>
            <td>Interfaz de usuario web</td>
            <td>Ecosistema maduro, reutilización de componentes con móvil</td>
          </tr>
          <tr>
            <td><strong>Frontend Móvil</strong></td>
            <td>React Native 0.73+</td>
            <td>Apps iOS/Android</td>
            <td>Compartir código con web, menor time-to-market</td>
          </tr>
          <tr>
            <td><strong>API Gateway</strong></td>
            <td>Apollo Gateway</td>
            <td>Punto de entrada único</td>
            <td>GraphQL Federation, mejor que REST tradicional</td>
          </tr>
          <tr>
            <td><strong>Microservicios</strong></td>
            <td>Node.js + GraphQL</td>
            <td>Lógica de negocio</td>
            <td>Worker Threads para paralelismo, GraphQL eficiente</td>
          </tr>
          <tr>
            <td><strong>Message Bus</strong></td>
            <td>Apache Kafka</td>
            <td>Comunicación asíncrona</td>
            <td>Alta throughput, durabilidad, ideal para SAGA</td>
          </tr>
          <tr>
            <td><strong>Orquestador</strong></td>
            <td>Kubernetes</td>
            <td>Gestión de contenedores</td>
            <td>Autoescalado, self-healing, standard de industria</td>
          </tr>
          <tr>
            <td><strong>Bases de Datos</strong></td>
            <td>PostgreSQL + MongoDB</td>
            <td>Persistencia</td>
            <td>CQRS: PostgreSQL para escritura, MongoDB para lectura</td>
          </tr>
          <tr>
            <td><strong>Caché</strong></td>
            <td>Redis</td>
            <td>Caché + Sesiones + SAGA</td>
            <td>Performance, estado temporal de SAGAs</td>
          </tr>
          <tr>
            <td><strong>Observabilidad</strong></td>
            <td>ELK + Prometheus</td>
            <td>Logs + Métricas</td>
            <td>Stack estándar, integración con K8s</td>
          </tr>
        </tbody>
      </table>
    </div>

    <h2>2.5 Flujo de Datos Principal</h2>

    <div class="section">
      <div class="diagram">
        <div class="diagram-title">Flujo de Request Típico</div>
        <pre class="mermaid">

sequenceDiagram
  actor U as Usuario (App)
  participant W as WAF
  participant AG as Apollo Gateway
  participant MS as MS-Históricos
  participant DB as MongoDB/Redis

  U->>W: GraphQL Query (HTTPS)
  Note over U,W: Solicita consulta de movimientos

  W->>AG: ✓ Request limpia
  Note over W: Valida origen y<br/>detecta patrones maliciosos

  AG->>MS: Enruta query
  Note over AG: Valida JWT y<br/>analiza complexity

  MS->>DB: Consulta datos
  Note over MS: Intenta cache hit<br/>en Redis (70% casos)
  
  DB-->>MS: Retorna datos
  Note over DB: Cache hit o<br/>query a MongoDB

  MS-->>AG: Datos procesados
  AG-->>W: GraphQL response
  W-->>U: Datos optimizados
  Note over U: 4 KB vs 11 KB en REST<br/>120ms vs 350ms latencia
        </pre>
      </div>
    </div>

    <h2>2.6 Principios Arquitectónicos</h2>

    <div class="section">
      <h3>2.6.1 Principios Fundamentales</h3>

      <ol>
        <li>
          <strong>API First con GraphQL:</strong>
          <p>
            Diseñar APIs antes de implementar, con GraphQL como protocolo
            principal para máxima eficiencia.
          </p>
        </li>

        <li>
          <strong>Desacoplamiento Total:</strong>
          <p>
            Microservicios independientes comunicados vía eventos asíncronos
            (Kafka).
          </p>
        </li>

        <li>
          <strong>Idempotencia:</strong>
          <p>
            Todas las operaciones críticas son idempotentes (pueden ejecutarse
            múltiples veces sin efectos adversos).
          </p>
        </li>

        <li>
          <strong>Observabilidad desde el Diseño:</strong>
          <p>
            Logs estructurados, métricas y traces implementados desde el primer
            día.
          </p>
        </li>

        <li>
          <strong>Security by Design:</strong>
          <p>Seguridad integrada en cada capa, no agregada después.</p>
        </li>

        <li>
          <strong>Fail Fast, Recover Faster:</strong>
          <p>Detectar fallos rápidamente y recuperarse automáticamente.</p>
        </li>
      </ol>

      <h3>2.6.2 Patrones Arquitectónicos Utilizados</h3>

      <table>
        <thead>
          <tr>
            <th>Patrón</th>
            <th>Aplicación</th>
            <th>Beneficio</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>CQRS</strong></td>
            <td>Separación lectura/escritura</td>
            <td>Optimización de performance en consultas</td>
          </tr>
          <tr>
            <td><strong>SAGA</strong></td>
            <td>Transacciones distribuidas</td>
            <td>Consistencia eventual con compensación</td>
          </tr>
          <tr>
            <td><strong>Event Sourcing</strong></td>
            <td>Auditoría y sincronización</td>
            <td>Trazabilidad completa, replay de eventos</td>
          </tr>
          <tr>
            <td><strong>Circuit Breaker</strong></td>
            <td>Llamadas entre servicios</td>
            <td>Previene cascading failures</td>
          </tr>
          <tr>
            <td><strong>Bulkhead</strong></td>
            <td>Aislamiento de recursos</td>
            <td>Fallo de un tipo de operación no afecta otros</td>
          </tr>
          <tr>
            <td><strong>API Gateway</strong></td>
            <td>Punto de entrada único</td>
            <td>Seguridad centralizada, routing inteligente</td>
          </tr>
          <tr>
            <td><strong>Database per Service</strong></td>
            <td>Cada microservicio su BD</td>
            <td>Independencia total, escalabilidad</td>
          </tr>
        </tbody>
      </table>
    </div>

    <h2>2.7 Capas de la Arquitectura</h2>

    <div class="section">
      <div class="table-container">
        <table>
          <thead>
            <tr>
              <th>Capa</th>
              <th>Responsabilidad Principal</th>
              <th>Tecnologías Clave</th>
              <th>Flujo / Interacciones</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><b>Capa 1: Presentación</b> 🖼️</td>
              <td>
                Interfaz con la que interactúa el usuario final (Cliente
                Web/Móvil).
              </td>
              <td>
                <code>React</code>, <code>React Native</code>,
                <code>Apollo Client</code>
              </td>
              <td>Envía peticiones del usuario hacia el API Gateway.</td>
            </tr>
            <tr>
              <td><b>Capa 2: API Gateway</b> 🚪</td>
              <td>
                Punto de entrada único que gestiona la seguridad y el
                enrutamiento.
              </td>
              <td>
                <code>Apollo Gateway</code>, <code>Kong</code>,
                <code>NGINX</code>
              </td>
              <td>
                Recibe peticiones de la Capa 1 y las dirige a los servicios
                correspondientes.
              </td>
            </tr>
            <tr>
              <td><b>Capa 3: Servicios de Aplicación</b> 🧠</td>
              <td>
                Contiene la lógica de negocio central, orquestando las
                operaciones.
              </td>
              <td><code>Microservicios en Node.js</code></td>
              <td>
                Recibe peticiones del API Gateway y utiliza las capas de
                Mensajería y Persistencia.
              </td>
            </tr>
            <tr>
              <td><b>Capa 4: Mensajería</b> 📨</td>
              <td>
                Gestiona la comunicación asíncrona y los eventos entre
                servicios.
              </td>
              <td><code>Apache Kafka</code></td>
              <td>
                Es utilizada por los Servicios de Aplicación para tareas en
                segundo plano.
              </td>
            </tr>
            <tr>
              <td><b>Capa 5: Persistencia</b> 💾</td>
              <td>
                Almacenamiento y recuperación de todos los datos de la
                aplicación.
              </td>
              <td><code>Bases de Datos</code>, <code>Caché</code></td>
              <td>
                Provee los datos que los Servicios de Aplicación necesitan para
                operar.
              </td>
            </tr>
            <tr>
              <td><b>Capa 6: Infraestructura</b> 🏗️</td>
              <td>
                Orquesta y ejecuta todos los servicios del backend en
                contenedores.
              </td>
              <td><code>Kubernetes</code>, <code>Docker</code></td>
              <td>
                Es la base sobre la que se despliegan y operan las capas 3, 4 y
                5.
              </td>
            </tr>
            <tr>
              <td><b>Capa Transversal: Observabilidad</b> 📊</td>
              <td>Monitorea la salud y el rendimiento de todo el sistema.</td>
              <td>
                <code>Prometheus</code>, <code>Grafana</code>,
                <code>ELK Stack</code>
              </td>
              <td>
                Recopila métricas y logs de todas las demás capas para análisis
                y alertas.
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

    <h2>2.8 Consideraciones de Diseño</h2>

    <div class="section">
      <div class="success">
        <strong>✓ Decisiones Clave Validadas:</strong>
        <ul>
          <li>GraphQL como protocolo principal reduce latencia 60-70%</li>
          <li>Microservicios permiten escalabilidad independiente</li>
          <li>Kafka garantiza comunicación asíncrona confiable</li>
          <li>CQRS optimiza lecturas sin impactar escrituras</li>
          <li>Patrón SAGA permite transacciones distribuidas</li>
        </ul>
      </div>

      <div class="note">
        <strong>Nota Importante:</strong> Esta arquitectura está diseñada para
        crecer de 50,000 usuarios iniciales hasta 10M+ usuarios sin necesidad de
        re-arquitectura, solo agregando más nodos horizontalmente.
      </div>
    </div>

    <div class="footer">
      <p>Propuesta de Arquitectura - Sistema Bancario BP | Capítulo 2 de 17</p>
    </div>
    <script src="mermaid.min.js"></script>
    <script src="panzoom.min.js"></script>
    <script src="app.js"></script>
  </body>
</html>
